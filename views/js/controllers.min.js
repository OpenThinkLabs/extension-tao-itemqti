/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 * 
 * 
 */

//@see http://forge.taotesting.com/projects/tao/wiki/Front_js
define('taoQtiItem/controller/routes',[],function(){
    

    return {
        'QtiPreview' : {
            'actions' : {
                'index' : 'taoItems/controller/preview/itemRunner'
            }
        },
        'QtiCreator' : {
          'actions' : {
            'index' : 'controller/creator/main'
          }
        }
    };
});

/**
 * Common basic util functions
 */
define('taoQtiItem/qtiItem/helper/util',[], function(){
    return {
        buildSerial : function buildSerial(prefix){
            var id = prefix || '';
            var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
            for(var i = 0; i < 22; i++){
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }
    }
});
define('taoQtiItem/qtiItem/helper/rendererConfig',['lodash', 'jquery'], function(_, $){

    var rendererConfigHelper = {};

    rendererConfigHelper.getOptionsFromArguments = function(args){

        var options = {
            data : {},
            placeholder : null,
            subclass : '',
            renderer : null
        };
        
        _.each(args, function(arg){
            if(arg){
                if(arg.isRenderer){
                    options.renderer = arg;
                }else if(arg instanceof $ && arg.length){
                    options.placeholder = arg;
                }else if(_.isString(arg)){
                    options.subclass = arg;
                }else if(_.isPlainObject(arg)){
                    options.data = arg;
                }else{
                    console.log('invalid arg', arg, args);
                }
            }
        });
        
//        console.log('args', options);
        
        return options;
    };
    
    return rendererConfigHelper;
});
define('taoQtiItem/qtiItem/core/Element',['class', 'lodash', 'taoQtiItem/qtiItem/helper/util', 'taoQtiItem/qtiItem/helper/rendererConfig'], function(Class, _, util, rendererConfig){

    var _instances = {};

    var Element = Class.extend({
        qtiClass : '',
        serial : '',
        relatedItem : null,
        init : function(serial, attributes){

            //init own attributes
            this.attributes = {};

            //system properties, for item creator internal use only
            this.metaData = {};

            //init call in the format init(attributes)
            if(typeof(serial) === 'object'){
                attributes = serial;
                serial = '';
            }

            if(!serial){
                serial = util.buildSerial(this.qtiClass + '_');
            }

            if(serial && (typeof serial !== 'string' || !serial.match(/^[a-z_0-9]*$/i))){
                throw 'invalid QTI serial : (' + (typeof serial) + ') ' + serial;
            }

            if(!_instances[serial]){
                _instances[serial] = this;
                this.serial = serial;
                this.setAttributes(attributes || {});
            }else{
                throw 'a QTI Element with the same serial already exists ' + serial;
            }

            if(typeof this.initContainer === 'function'){
                this.initContainer(arguments[2] || '');
            }
            if(typeof this.initObject === 'function'){
                this.initObject();
            }
        },
        is : function(qtiClass){
            return (qtiClass === this.qtiClass);
        },
        placeholder : function(){
            return '{{' + this.serial + '}}';
        },
        getSerial : function(){
            return this.serial;
        },
        getUsedIdentifiers : function(){
            var usedIds = {};
            var elts = this.getComposingElements();
            for(var i in elts){
                var elt = elts[i];
                var id = elt.attr('identifier');
                if(id){
                    //warning: simplistic implementation, allow only one unique identifier in the item no matter the element class/type
                    usedIds[id] = elt;
                }
            }
            return usedIds;
        },
        attr : function(name, value){
            if(name){
                if(value !== undefined){
                    this.attributes[name] = value;
                }else{
                    if(typeof(name) === 'object'){
                        for(var prop in name){
                            this.attr(prop, name[prop]);
                        }
                    }else if(typeof(name) === 'string'){
                        if(this.attributes[name] === undefined){
                            return undefined;
                        }else{
                            return this.attributes[name];
                        }
                    }
                }
            }
            return this;
        },
        data : function(name, value){
            if(name){
                if(value !== undefined){
                    this.metaData[name] = value;
                    $(document).trigger('metaChange.qti-widget', {element : this, key : name, value : value});
                }else{
                    if(typeof(name) === 'object'){
                        for(var prop in name){
                            this.data(prop, name[prop]);
                        }
                    }else if(typeof(name) === 'string'){
                        if(this.metaData[name] === undefined){
                            return undefined;
                        }else{
                            return this.metaData[name];
                        }
                    }
                }
            }
            return this;
        },
        removeData : function(name){
            delete this.metaData[name];
            return this;
        },
        removeAttr : function(name){
            return this.removeAttributes(name);
        },
        setAttributes : function(attributes){
            this.attributes = attributes;
            return this;
        },
        getAttributes : function(){
            return _.clone(this.attributes);
        },
        removeAttributes : function(attrNames){
            if(typeof(attrNames) === 'string'){
                attrNames = [attrNames];
            }
            for(var i in attrNames){
                delete this.attributes[attrNames[i]];
            }
            return this;
        },
        getComposingElements : function(){
            var elts = {};
            if(typeof this.initContainer === 'function'){
                var container = this.getBody();
                elts[container.getSerial()] = container;//pass individual object by ref, instead of the whole list(object)
                elts = _.extend(elts, container.getComposingElements());
            }
            if(typeof this.initObject === 'function'){
                var object = this.getObject();
                elts[object.getSerial()] = object;//pass individual object by ref, instead of the whole list(object)
                elts = _.extend(elts, object.getComposingElements());
            }
            return elts;
        },
        getUsedClasses : function(){

            var ret = [this.qtiClass],
                composingElts = this.getComposingElements();

            _.each(composingElts, function(elt){
                ret.push(elt.qtiClass);
            });

            return _.uniq(ret);
        },
        find : function(serial){

            var found = null;

            if(typeof this.initObject === 'function'){
                var object = this.getObject();
                if(object.serial === serial){
                    found = {'parent' : this, 'element' : object, 'location' : 'object'};
                }
            }

            if(!found && typeof this.initContainer === 'function'){
                found = this.getBody().find(serial, this);
            }

            return found;
        },
        parent : function(){
            var item = this.getRelatedItem();
            if(item){
                var found = item.find(this.getSerial());
                if(found){
                    return found.parent;
                }
            }
            return null;
        },
        setRelatedItem : function(item, recursive){

            recursive = (typeof recursive === 'undefined') ? true : recursive;

            if(Element.isA(item, 'assessmentItem')){
                this.relatedItem = item;
                var composingElts = this.getComposingElements();
                for(var i in composingElts){
                    composingElts[i].setRelatedItem(item, false);
                }
            }

        },
        getRelatedItem : function(){
            var ret = null;
            if(Element.isA(this.relatedItem, 'assessmentItem')){
                ret = this.relatedItem;
            }
            return ret;
        },
        setRenderer : function(renderer){
            if(renderer && renderer.isRenderer){
                this.renderer = renderer;
                var elts = this.getComposingElements();
                for(var serial in elts){
                    elts[serial].setRenderer(renderer);
                }
            }else{
                throw 'invalid qti rendering engine';
            }
        },
        getRenderer : function(){
            return this.renderer;
        },
        render : function(){

            var args = rendererConfig.getOptionsFromArguments(arguments);
            var renderer = args.renderer || this.getRenderer();

            var tplData = {},
                defaultData = {
                'tag' : this.qtiClass,
                'serial' : this.serial,
                'attributes' : this.getAttributes()
            };

            if(!renderer){
                throw 'render: no renderer found for the element ' + this.qtiClass + ':' + this.serial;
            }

            if(typeof this.initContainer === 'function'){
                defaultData.body = this.getBody().render(renderer);
            }
            if(typeof this.initObject === 'function'){
                defaultData.object = {
                    attributes : this.object.getAttributes()
                };
                var url = defaultData.object.attributes.data;
                var baseUrl = renderer.getOption('baseUrl');
                if(baseUrl){
                    if(!/^http(s)?:\/\//.test(url)){
                        defaultData.object.attributes.data = baseUrl + url;
                    }
                }
            }

            tplData = _.merge(defaultData, args.data || {});
            tplData = renderer.getData(this, tplData, args.subclass);
            var rendering = renderer.renderTpl(this, tplData, args.subclass);
            if(args.placeholder){
                args.placeholder.replaceWith(rendering);
            }

            return rendering;
        },
        postRender : function(data, altClassName, renderer){

            renderer = renderer || this.getRenderer();

            if(typeof this.initContainer === 'function'){
                //post render body element
                this.getBody().postRender({}, '', renderer);
            }

            if(renderer){
                return renderer.postRender(this, data, altClassName);
            }else{
                throw 'postRender: no renderer found for the element ' + this.qtiClass + ':' + this.serial;
            }
        },
        getContainer : function($scope, subclass){
            var renderer = this.getRenderer();
            if(renderer){
                return renderer.getContainer(this, $scope, subclass);
            }else{
                throw 'getContainer: no renderer found for the element ' + this.qtiClass + ':' + this.serial;
            }
        },
        toArray : function(){
            var arr = {
                serial : this.serial,
                type : this.qtiClass,
                attributes : this.getAttributes()
            };

            if(typeof this.initContainer === 'function'){
                arr.body = this.getBody().toArray();
            }
            if(typeof this.initObject === 'function'){
                arr.object = this.object.toArray();
            }

            return arr;
        },
        remove : function(containerPropName, element){
            console.log('element.remove() : deprecated method')
            if(this[containerPropName]){
                var serial = '';
                if(typeof(element) === 'string'){
                    serial = element;
                }else if(element instanceof Element){
                    serial = element.getSerial();
                }
                if(serial){
                    delete this[containerPropName][serial];
                }
            }
            return this;
        },
        isEmpty : function(){
            //tells whether the element should be considered empty or not, from the rendering point of view
            return false;
        },
        addClass : function(className){
            var clazz = this.attr('class') || '';
            if(!_containClass(clazz, className)){
                this.attr('class', clazz + (clazz.length ? ' ' : '') + className);
            }
        },
        hasClass : function(className){
            return _containClass(this.attr('class'), className);
        },
        removeClass : function(className){

            var clazz = this.attr('class') || '';
            if(clazz){
                var regex = new RegExp('(?:^|\\s)' + className + '(?:\\s|$)', '');
                clazz = clazz.replace(regex, '').replace(/^\s+/, '');
                if(clazz){
                    this.attr('class', clazz);
                }else{
                    this.removeAttr('class');
                }
            }
        }
    });

    var _containClass = function(allClassStr, className){
        var regex = new RegExp('(?:^|\\s)' + className + '(?:\\s|$)', '');
        return allClassStr && regex.test(allClassStr);
    };

    //helpers
    Element.isA = function(qtiElement, qtiClass){
        return (qtiElement instanceof Element && qtiElement.is(qtiClass));
    };

    Element.getElementBySerial = function(serial){
        return _instances[serial];
    };

    Element.unsetElement = function(serial){
        delete _instances[serial];
    };

    return Element;
});



/**
 * Common helper functions
 */
define('taoQtiItem/qtiItem/helper/interactionHelper',['lodash', 'taoQtiItem/qtiItem/core/Element'], function(_, Element){
    return {
        convertChoices : function(choices, outputType){

            var ret = [], _this = this;

            _.each(choices, function(c){
                if(Element.isA(c, 'choice')){
                    switch(outputType){
                        case 'serial':
                            ret.push(c.getSerial());
                            break;
                        case 'identifier':
                            ret.push(c.id());
                            break;
                        default:
                            ret.push(c);
                    }

                }else if(_.isArray(c)){
                    ret.push(_this.convertChoices(c, outputType));
                }
            });

            return ret;
        },
        findChoices : function(interaction, choices, inputType){

            var ret = [], _this = this;

            _.each(choices, function(c){
                var choice;
                if(_.isString(c)){
                    if(inputType === 'serial'){
                        choice = interaction.getChoice(c);
                        if(choice){
                            ret.push(choice);
                        }
                    }else if(inputType === 'identifier'){
                        choice = interaction.getChoiceByIdentifier(c);
                        if(choice){
                            ret.push(choice);
                        }
                    }else{
                        ret.push(c);
                    }
                }else if(_.isArray(c)){
                    ret.push(_this.findChoices(interaction, c, inputType));
                }else{
                    ret.push(c);
                }
            });

            return ret;
        },
        shuffleChoices : function(choices){
            var r = [], //returned array
                f = {}, //fixed choices array
                j = 0;

            for(var i in choices){
                if(Element.isA(choices[i], 'choice')){
                    var choice = choices[i];
                    if(choice.attr('fixed')){
                        f[j] = choice;
                    }
                    r.push(choice);
                    j++;
                }else{
                    throw 'invalid element in array: is not a qti choice';
                }
            }

            for(var n = 0; n < r.length - 1; n++){
                if(f[n]){
                    continue;
                }
                var k = -1;
                do{
                    k = n + Math.floor(Math.random() * (r.length - n));
                }while(f[k]);
                var tmp = r[k];
                r[k] = r[n];
                r[n] = tmp;
            }

            return r;
        },
        serialToIdentifier : function(interaction, choiceSerial){
            var choice = interaction.getChoice(choiceSerial);
            if(choice){
                return choice.id();
            }else{
                return '';
            }
        }
    }
});
define('taoQtiItem/qtiRunner/core/Renderer',[
    'lodash',
    'jquery',
    'handlebars',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiItem/helper/interactionHelper'
], function(_, $, Handlebars, Element, interactionHelper){

    

    var _isValidRenderer = function(renderer){

        var valid = true;

        if(typeof(renderer) !== 'object'){
            return false;
        }

        var classCorrect = false;
        if(renderer.qtiClass){
            if(_.indexOf(_renderableClasses, renderer.qtiClass) >= 0){
                classCorrect = true;
            }else{
                var pos = renderer.qtiClass.indexOf('.');
                if(pos > 0){
                    var qtiClass = renderer.qtiClass.slice(0, pos);
                    var subClass = renderer.qtiClass.slice(pos + 1);
                    if(_renderableSubclasses[qtiClass] && _.indexOf(_renderableSubclasses[qtiClass], subClass) >= 0){
                        classCorrect = true;
                    }
                }
            }
        }
        if(!classCorrect){
            valid = false;
            throw new Error('invalid qti class name in renderer declaration : ' + renderer.qtiClass);
        }

        if(!renderer.template){
            valid = false;
            throw new Error('missing template in renderer declaration : ' + renderer.qtiClass);
        }

        return valid;
    };

    var _renderableClasses = [
        '_container',
        'assessmentItem',
        'stylesheet',
        'responseDeclaration',
        'outcomeDeclaration',
        'responseProcessing',
        '_simpleFeedbackRule',
        'img',
        'math',
        'object',
        'modalFeedback',
        'rubricBlock',
        'associateInteraction',
        'choiceInteraction',
        'extendedTextInteraction',
        'gapMatchInteraction',
        'graphicAssociateInteraction',
        'graphicGapMatchInteraction',
        'graphicOrderInteraction',
        'hotspotInteraction',
        'hottextInteraction',
        'inlineChoiceInteraction',
        'matchInteraction',
        'mediaInteraction',
        'orderInteraction',
        'selectPointInteraction',
        'sliderInteraction',
        'textEntryInteraction',
        'uploadInteraction',
        'endAttemptInteraction',
        'prompt',
        'associableHotspot',
        'gap',
        'gapImg',
        'gapText',
        'hotspotChoice',
        'hottext',
        'inlineChoice',
        'simpleAssociableChoice',
        'simpleChoice'
    ];

    var _renderableSubclasses = {
        'simpleAssociableChoice' : ['associateInteraction', 'matchInteraction'],
        'simpleChoice' : ['choiceInteraction', 'orderInteraction']
    };

    var _alwaysRequiredClasses = [
        '_container',
        'prompt',
        'modalFeedback'
    ];

    var Renderer = function(options){

        options = options || {};
        
        this.isRenderer = true;
        this.name = '';
        this.shuffleChoices = (options.shuffleChoices !== undefined)? options.shuffleChoices : true;
        
        this.shuffledChoices = [];

        /**
         * Store the registered renderer location
         */
        var _locations = {};

        /**
         * Store loaded renderers
         */
        var _renderers = {};

        /**
         * Get the actual renderer of the give qti class or subclass:
         * e.g. simplceChoice, simpleChoice.choiceInteraction, simpleChoice.orderInteraction
         */
        var _getClassRenderer = function(qtiClass){
            var ret = null;
            if(_renderers[qtiClass]){
                ret = _renderers[qtiClass];
            }else{
                var pos = qtiClass.indexOf('.');
                if(pos > 0){
                    qtiClass = qtiClass.slice(0, pos);
                    if(_renderers[qtiClass]){
                        ret = _renderers[qtiClass]
                    }
                }
            }
            return ret;
        };
        
        this.setOption = function(key, value){
            if(typeof(key) === 'string'){
                options[key] = value;
            }
            return this;
        };
        
        this.setOptions = function(opts){
            _.extend(options, opts);
            return this;
        };
        
        this.getOption = function(key){
            if(typeof(key) === 'string' && options[key]){
                return options[key];
            }
            return null;
        };

        this.renderTpl = function(element, data, qtiSubclass){
            
            var ret = '',
                tplFound = false,
                qtiClass = qtiSubclass || element.qtiClass,
                renderer = _getClassRenderer(qtiClass);

            if(renderer){
                if(typeof(renderer.template) === 'function'){
                    ret = renderer.template(data);
                    tplFound = true;
                }
            }
            
            if(!tplFound){
                throw new Error('no renderer template loaded under the class name : ' + qtiClass);
            }

            return ret;
        };

        this.getData = function(element, data, qtiSubclass){

            var ret = data,
                qtiClass = qtiSubclass || element.qtiClass,
                renderer = _getClassRenderer(qtiClass);

            if(renderer){
                if(typeof(renderer.getData) === 'function'){
                    ret = renderer.getData.call(this, element, data);
                }
            }

            return ret;
        };

        this.renderDirect = function(tpl, data){
            return Handlebars.compile(tpl)(data);
        };

        this.getContainer = function(qtiElement, $scope, qtiSubclass){

            var ret = null,
                qtiClass = qtiSubclass || qtiElement.qtiClass,
                renderer = _getClassRenderer(qtiClass);

            if(renderer){
                ret = renderer.getContainer(qtiElement, $scope);
            }else{
                throw 'no renderer found for the class : ' + qtiElement.qtiClass;
            }
            return ret;
        };

        this.postRender = function(qtiElement, data, qtiSubclass){

            var ret = false,
                qtiClass = qtiSubclass || qtiElement.qtiClass,
                renderer = _getClassRenderer(qtiClass);

            if(renderer){
                if(typeof(renderer.render) === 'function'){
                    ret = renderer.render.call(this, qtiElement, data);
                }else{
                    //postRendering is optional, log missing call of postRender?
                }
            }

            return ret;
        };

        this.setResponse = function(qtiInteraction, response, qtiSubclass){
            
            var ret = false, 
                qtiClass = qtiSubclass || qtiInteraction.qtiClass,
                renderer = _getClassRenderer(qtiClass);
            
            if(renderer){
                if(typeof(renderer.setResponse) === 'function'){
                    ret = renderer.setResponse.call(this, qtiInteraction, response);
                    var $container = renderer.getContainer.call(this, qtiInteraction);
                    if($container instanceof $ && $container.length){
                        $container.trigger('responseSet', [qtiInteraction, response]);
                    }
                }
            }else{
                throw 'no renderer registered under the name : ' + qtiClass;
            }
            return ret;
        };

        this.getResponse = function(qtiInteraction, qtiSubclass){
            
            var ret = false, 
                qtiClass = qtiSubclass || qtiInteraction.qtiClass,
                renderer = _getClassRenderer(qtiClass);
            
            if(renderer){
                if(typeof(renderer.getResponse) === 'function'){
                    ret = renderer.getResponse.call(this, qtiInteraction);
                }
            }else{
                throw 'no renderer registered under the name : ' + qtiClass;
            }
            return ret;
        };
        
        this.resetResponse = function(qtiInteraction, qtiSubclass){
            
            var ret = false, 
                qtiClass = qtiSubclass || qtiInteraction.qtiClass,
                renderer = _getClassRenderer(qtiClass);
            
            if(renderer){
                if(typeof(renderer.resetResponse) === 'function'){
                    ret = renderer.resetResponse.call(this, qtiInteraction);
                }
            }else{
                throw 'no renderer registered under the name : ' + qtiClass;
            }
            return ret;
        };

        this.getLoadedRenderers = function(){
            return _renderers;
        };

        this.register = function(renderersLocations){
            _.extend(_locations, renderersLocations);
        };

        this.load = function(callback, requiredClasses){

            var required = [];
            if(requiredClasses){
                if(_.isArray(requiredClasses)){
                    requiredClasses = _.intersection(requiredClasses, _renderableClasses);
                    requiredClasses = _.union(requiredClasses, _alwaysRequiredClasses);
                    for(var i in requiredClasses){
                        var qtiClass = requiredClasses[i];
                        if(_renderableSubclasses[qtiClass]){
                            var requiredSubClasses = _.intersection(requiredClasses, _renderableSubclasses[qtiClass]);
                            _.each(requiredSubClasses, function(subclass){
                                if(_locations[qtiClass + '.' + subclass]){
                                    required.push(_locations[qtiClass + '.' + subclass]);
                                }else if(_locations[qtiClass]){
                                    required.push(_locations[qtiClass]);
                                }else{
                                    throw new Error(this.name + ' : missing qti class location declaration: ' + qtiClass + ', subclass: ' + subclass);
                                }
                            });
                        }else{
                            if(_locations[qtiClass] === false){
                                _renderers[qtiClass] = false;//mark this class as not renderable
                            }else if(_locations[qtiClass]){
                                required.push(_locations[qtiClass]);
                            }else{
                                throw new Error(this.name + ' : missing qti class location declaration: ' + qtiClass);
                            }
                        }
                    }
                }else{
                    throw new Error('invalid argument type: expected array for arg "requireClasses"');
                }
            }else{
                required = _.values(_locations);
            }

            var _this = this;
            require(required, function(){

                _.each(arguments, function(clazz){
                    if(_isValidRenderer(clazz)){
                        _renderers[clazz.qtiClass] = clazz;
                    }
                });

                if(typeof(callback) === 'function'){
                    callback.call(_this, _renderers);
                }
            });
            
            return this;
        };

        this.setShuffledChoices = function(interaction, choices, identificationType){
            if(Element.isA(interaction, 'interaction')){
                this.shuffledChoices[interaction.getSerial()] = interactionHelper.findChoices(interaction, choices, identificationType);
            }
        };

        this.getShuffledChoices = function(interaction, reshuffle, returnedType){
            var ret = [], tmp;

            if(Element.isA(interaction, 'interaction')){
                var serial = interaction.getSerial();
                if(!this.shuffledChoices[serial] || reshuffle){
                    if(Element.isA(interaction, 'matchInteraction')){
                        this.shuffledChoices[serial] = [];
                        for(var i = 0; i < 2; i++){
                            this.shuffledChoices[serial].push(interactionHelper.shuffleChoices(interaction.getChoices(i)))
                        }
                    }else{
                        this.shuffledChoices[serial] = interactionHelper.shuffleChoices(interaction.getChoices());
                    }
                }
                tmp = this.shuffledChoices[serial];

                if(returnedType === 'serial' || returnedType === 'identifier'){
                    ret = interactionHelper.convertChoices(tmp, returnedType);
                }else{
                    //pass value only, not ref
                    ret = _.clone(tmp);
                }
            }

            return ret;
        };
        
        this.getRenderers = function(){
            return _renderers;
        };
        
        this.getLocations = function(){
            return _locations;
        };

    };

    return {
        build : function(renderersLocations, name){
            var NewRenderer = function(){
                Renderer.apply(this, arguments);
                this.register(renderersLocations);
                this.name = name || '';
            };
            NewRenderer.prototype = Renderer.prototype;
            return NewRenderer;
        },
        getElementRenderer : function(ElementRenderer, element){
            if(element.qtiClass === ElementRenderer.qtiClass){
                var currentRenderer = element.getRenderer();
            }
        }
    };
});
define('taoQtiItem/qtiDefaultRenderer/renderers/config',[],function(){
    return {
        name : 'defaultRenderer',
        locations : {
            '_container' : 'taoQtiItem/qtiDefaultRenderer/renderers/Container',
            'assessmentItem' : 'taoQtiItem/qtiDefaultRenderer/renderers/Item',
            'stylesheet' : 'taoQtiItem/qtiDefaultRenderer/renderers/Stylesheet',
            'outcomeDeclaration' : 'taoQtiItem/qtiDefaultRenderer/renderers/OutcomeDeclaration',
            'responseDeclaration' : 'taoQtiItem/qtiDefaultRenderer/renderers/ResponseDeclaration',
            'responseProcessing' : 'taoQtiItem/qtiDefaultRenderer/renderers/ResponseProcessing',
            'math' : 'taoQtiItem/qtiDefaultRenderer/renderers/Math',
            'object' : 'taoQtiItem/qtiDefaultRenderer/renderers/Object',
            'modalFeedback' : 'taoQtiItem/qtiDefaultRenderer/renderers/ModalFeedback',
            'rubricBlock' : 'taoQtiItem/qtiDefaultRenderer/renderers/RubricBlock',
            'associateInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/AssociateInteraction',
            'choiceInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/ChoiceInteraction',
            'extendedTextInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/ExtendedTextInteraction',
            'gapMatchInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/GapMatchInteraction',
            'graphicAssociateInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/GraphicAssociateInteraction',
            'graphicGapMatchInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/GraphicGapMatchInteraction',
            'graphicOrderInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/GraphicOrderInteraction',
            'hotspotInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/HotspotInteraction',
            'hottextInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/HottextInteraction',
            'inlineChoiceInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/InlineChoiceInteraction',
            'matchInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/MatchInteraction',
            'mediaInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/MediaInteraction',
            'orderInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/OrderInteraction',
            'selectPointInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/SelectPointInteraction',
            'sliderInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/SliderInteraction',
            'textEntryInteraction' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/TextEntryInteraction',
            'prompt' : 'taoQtiItem/qtiDefaultRenderer/renderers/interactions/Prompt',
            'associableHotspot' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/AssociableHotspot',
            'gap' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/Gap',
            'gapImg' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/GapImg',
            'gapText' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/GapText',
            'hotspotChoice' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/HotspotChoice',
            'hottext' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/Hottext',
            'inlineChoice' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/InlineChoice',
            'simpleAssociableChoice' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/SimpleAssociableChoice',
            'simpleChoice' : 'taoQtiItem/qtiDefaultRenderer/renderers/choices/SimpleChoice'
        }
    }
});
define('taoQtiItem/qtiCommonRenderer/renderers/config',['lodash', 'taoQtiItem/qtiDefaultRenderer/renderers/config'], function(_, defaultRenderConfig){
    var locations = _.extend(_.clone(defaultRenderConfig.locations), {
        'assessmentItem' : 'taoQtiItem/qtiCommonRenderer/renderers/Item',
        '_container' : 'taoQtiItem/qtiCommonRenderer/renderers/Container',
        '_simpleFeedbackRule' : false,
        'stylesheet' : 'taoQtiItem/qtiCommonRenderer/renderers/Stylesheet',
        'img' : 'taoQtiItem/qtiCommonRenderer/renderers/Img',
        'math' : 'taoQtiItem/qtiCommonRenderer/renderers/Math',
        'rubricBlock' : 'taoQtiItem/qtiCommonRenderer/renderers/RubricBlock',
        'modalFeedback' : 'taoQtiItem/qtiCommonRenderer/renderers/ModalFeedback',
        'prompt' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/Prompt',
        'choiceInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/ChoiceInteraction',
        'extendedTextInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/ExtendedTextInteraction',
        'orderInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/OrderInteraction',
        'associateInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/AssociateInteraction',
        'matchInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/MatchInteraction',
        'textEntryInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/TextEntryInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/SliderInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/InlineChoiceInteraction',
        'simpleChoice.choiceInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/SimpleChoice.ChoiceInteraction',
        'simpleChoice.orderInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/SimpleChoice.OrderInteraction',
        'hottext' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/Hottext',
        'gap' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/Gap',
        'gapText' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/GapText',
        'simpleAssociableChoice.matchInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/SimpleAssociableChoice.MatchInteraction',
        'simpleAssociableChoice.associateInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/SimpleAssociableChoice.AssociateInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/SliderInteraction',
        'inlineChoice' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/InlineChoice',
        'hottextInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/HottextInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/HotspotInteraction',
        'gapMatchInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/GapMatchInteraction',
        'selectPointInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/SelectPointInteraction',
        'graphicOrderInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/GraphicOrderInteraction',
        'mediaInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/MediaInteraction',
        'uploadInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/UploadInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/GraphicGapMatchInteraction',
        'gapImg' : 'taoQtiItem/qtiCommonRenderer/renderers/choices/GapImg',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiCommonRenderer/renderers/interactions/GraphicAssociateInteraction'
    });
    return {
        name:'commonRenderer',
        locations : locations
    };
});





define('taoQtiItem/qtiCommonRenderer/renderers/Renderer',[
    'taoQtiItem/qtiRunner/core/Renderer',
    'taoQtiItem/qtiCommonRenderer/renderers/config',
    'css!taoQtiItem_css/qti',
    'css!tao_css/tao-main-style'// not until fonts are separated
], function(Renderer, config){
    return Renderer.build(config.locations, config.name);
});


define('tpl!taoQtiItem/qtiCommonRenderer/tpl/instruction', ['handlebars'], function(Handlebars){ 
return Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"";
  if (helper = helpers.serial) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.serial); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"small feedback-info item-instruction\">\n    <span class=\"icon-info icon\"></span><span class=\"instruction-message\">";
  if (helper = helpers.message) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.message); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n</div>";
  return buffer;
  });
});

define('taoQtiItem/qtiCommonRenderer/helpers/Instruction',[
    'lodash',
    'taoQtiItem/qtiItem/helper/util',
    'tpl!taoQtiItem/qtiCommonRenderer/tpl/instruction',
], function(_, util, instructionTpl){

    var _notificationLevels = ['info', 'warning', 'error', 'success'];

    var Instruction = function(interaction, message, callback){
        this.interaction = interaction;
        this.defaultMessage = message || '';
        this.currentMessage = '';
        this.level = 'info';
        this.serial = util.buildSerial('instruction_');
        this.callback = callback;
        this.$dom = null;
        this.state = false;
    };

    Instruction.isValidLevel = function(level){
        return (_.indexOf(_notificationLevels, level) >= 0);
    };

    Instruction.prototype.setState = function(state){
        this.state = state;
    };

    Instruction.prototype.checkState = function(state){
        return (this.state === state);
    };

    Instruction.prototype.getId = function(){
        return this.serial;
    };

    Instruction.prototype.create = function($container){

        $container.append(instructionTpl({
            'message' : this.defaultMessage,
            'serial' : this.serial
        }));

        this.$dom = $container.find('#' + this.serial);
    };

    Instruction.prototype.update = function(options){

        var level = (options && options.level) ? options.level : '',
            message = (options && options.message) ? options.message : '',
            timeout = (options && options.timeout) ? options.timeout : 0,
            start = (options && typeof(options.start) === 'function') ? options.start : null,
            stop = (options && typeof(options.stop) === 'function') ? options.stop : null;

        if(level && Instruction.isValidLevel(level)){
            this.$dom.removeClass('feedback-' + this.level).addClass('feedback-' + level);
            this.$dom.find('.icon').removeClass('icon-' + this.level).addClass('icon-' + level);
            this.level = level;
        }

        if(message){
            this.$dom.find('.instruction-message').html(message);
            this.currentMessage = message;
        }

        if(timeout){
            var _this = this;
            if(start){
                start.call(_this);
            }
            _this.timer = setTimeout(function(){
                if(stop){
                    stop.call(_this);
                }
                _this.timer = null;
            }, timeout);
        }

    };

    Instruction.prototype.setLevel = function(level, timeout){
        var options = {
            level : level
        };
        
        if(timeout){
            options.timeout = parseInt(timeout);
            options.stop = function(){
                this.setLevel('info');
            };
        }
        
        this.update(options);
    };
    
    Instruction.prototype.getLevel = function() {
        return this.level;
    }

    Instruction.prototype.setMessage = function(message, timeout){
        this.update({message : message, timeout : timeout});
    };

    Instruction.prototype.reset = function(){
        this.update({level : 'info', message : this.defaultMessage});
        this.state = false;
    };

    Instruction.prototype.validate = function(data){
        if(typeof(this.callback) === 'function'){
            this.callback.call(this, data);
        }
    };

    return Instruction;
});


define('tpl!taoQtiItem/qtiCommonRenderer/tpl/notification', ['handlebars'], function(Handlebars){ 
return Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"small feedback-";
  if (helper = helpers.level) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.level); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " item-notification\">\n    <span class=\"icon-";
  if (helper = helpers.level) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.level); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></span><span class=\"feedback-message\">";
  if (helper = helpers.message) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.message); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    <span title=\"Remove Message\" class=\"icon-close close-trigger\"></span>\n</div>";
  return buffer;
  });
});

define('taoQtiItem/qtiCommonRenderer/helpers/Helper',[
    'lodash',
    'jquery',
    'i18n',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiCommonRenderer/helpers/Instruction',
    'tpl!taoQtiItem/qtiCommonRenderer/tpl/notification'
], function(_, $, __, Element, Instruction, notifTpl){

    var _containers = {};
    var _instructions = {};
    var _$containerContext = $();

    var _getSelector = function(element){

        var serial = element.getSerial(),
            selector = '[data-serial=' + serial + ']';

        if(Element.isA(element, 'choice')){
            selector = '.qti-choice' + selector;
        }else if(Element.isA(element, 'interaction')){
            selector = '.qti-interaction' + selector;
        }

        return selector;
    };

    return {
        setContext : function($scope){
            _$containerContext = $scope;
        },
        getContainer : function(element, $scope){
            
            var serial = element.getSerial();
            
            if($scope instanceof $ && $scope.length){
                
                //find in the given context
                return $scope.find(_getSelector(element));
                
            }else if(_$containerContext instanceof $ && _$containerContext.length){
                
                //find in the globally set context
                return _$containerContext.find(_getSelector(element));
                
            }else if(!_containers[serial] || _containers[serial].length){
                
                //find in the global context
                _containers[serial] = $(_getSelector(element));
            }

            return _containers[serial];
        },
        validateInstructions : function(element, data){
            var serial = element.getSerial();
            if(_instructions[serial]){
                _.each(_instructions[serial], function(instruction){
                    instruction.validate(data);
                });
            }
        },
        appendInstruction : function(element, message, validateCallback){
            var serial = element.getSerial(),
                instruction = new Instruction(element, message, validateCallback);

            if(!_instructions[serial]){
                _instructions[serial] = {};
            }
            _instructions[serial][instruction.getId()] = instruction;

            instruction.create(this.getContainer(element).find('.instruction-container'));

            return instruction;
        },
        removeInstructions : function(element){
            _instructions[element.getSerial()] = {};
            this.getContainer(element).find('.instruction-container').empty();
        },
        /**
         * Reset the instructions states for an element (but keeps configuration)
         * @param {Object} element - the qti object, ie. interaction, choice, etc.
         */
        resetInstructions : function(element){
            var serial = element.getSerial();
            if(_instructions[serial]){
                _.each(_instructions[serial], function(instruction){
                    instruction.reset();
                });
            }
        },
        /** 
         * Default instuction set with a min/max constraints.
         * @param {Object} interaction
         * @param {Object} options
         * @param {Number} [options.min = 0] - 
         * @param {Number} [options.max = 0] - 
         * @param {Function} options.getResponse - a ref to a function that get the raw response (array) from the interaction in parameter
         * @param {Function} [options.onError] - called by once an error occurs with validateInstruction data in parameters
         */
        minMaxChoiceInstructions : function(interaction, options){

            var self = this,
                min = options.min || 0,
                max = options.max || 0,
                getResponse = options.getResponse,
                onError = options.onError || _.noop(),
                choiceCount = options.choiceCount === false ? false : _.size(interaction.getChoices()),
                minInstructionSet = false,
                msg;

            if(!_.isFunction(getResponse)){
                throw "invalid parameter getResponse";
            }

            //if maxChoice = 0, inifinite choice possible
            if(max > 0 && (choiceCount === false || max < choiceCount)){
                if(max === min){
                    minInstructionSet = true;
                    msg = (max <= 1) ? __('You must select exactly %d choice', max) : __('You must select exactly %d choices', max);

                    self.appendInstruction(interaction, msg, function(data){

                        if(getResponse(interaction).length >= max){
                            this.setLevel('success');
                            if(this.checkState('fulfilled')){
                                this.update({
                                    level : 'warning',
                                    message : __('Maximum choices reached'),
                                    timeout : 2000,
                                    start : function(){
                                        onError(data);
                                    },
                                    stop : function(){
                                        this.update({level : 'success', message : msg});
                                    }
                                });
                            }
                            this.setState('fulfilled');
                        }else{
                            this.reset();
                        }
                    });
                }else if(max > min){
                    msg = (max <= 1) ? __('You can select maximum %d choice', max) : __('You can select maximum %d choices', max);
                    self.appendInstruction(interaction, msg, function(data){

                        if(getResponse(interaction).length >= max){

                            this.setLevel('success');
                            this.setMessage(__('Maximum choices reached'));
                            if(this.checkState('fulfilled')){
                                this.update({
                                    level : 'warning',
                                    timeout : 2000,
                                    start : function(){
                                        onError(data);
                                    },
                                    stop : function(){
                                        this.setLevel('info');
                                    }
                                });
                            }

                            this.setState('fulfilled');
                        }else{
                            this.reset();
                        }
                    });
                }
            }

            if(!minInstructionSet && min > 0 && (choiceCount === false || min < choiceCount)){
                msg = (min <= 1) ? __('You must at least %d choice', min) : __('You must select at least %d choices', max);
                self.appendInstruction(interaction, msg, function(){
                    if(getResponse(interaction).length >= min){
                        this.setLevel('success');
                    }else{
                        this.reset();
                    }
                });
            }
        },
        appendNotification : function(element, message, level){

            level = level || 'info';

            if(Instruction.isValidLevel(level)){

                var $container = this.getContainer(element);

                $container.find('.notification-container').prepend(notifTpl({
                    'level' : level,
                    'message' : message
                }));

                var $notif = $container.find('.item-notification:first');
                var _remove = function(){
                    $notif.fadeOut();
                };

                $notif.find('.close-trigger').on('click', _remove);
                setTimeout(_remove, 2000);

                return $notif;
            }
        },
        removeNotifications : function(element){
            this.getContainer(element).find('.item-notification').remove();
        },
        triggerResponseChangeEvent : function(interaction, extraData){
            this.getContainer(interaction).trigger('responseChange', [{
                    interaction : interaction,
                    response : interaction.getResponse()
                },
                extraData
            ]);
        }
    };
});

define('taoQtiItem/qtiCreator/helper/commonRenderer',[
    'taoQtiItem/qtiCommonRenderer/renderers/Renderer',
    'taoQtiItem/qtiCommonRenderer/helpers/Helper'
], function(Renderer, commonHelper){
    
    //store the curret execution context of the common renderer (preview)
    var _$previousContext = null;
    
    //configure and instanciate once only:
    var _renderer = new Renderer({
        baseUrl : '',
        shuffleChoices : true
    });
    
    
    var commonRenderer = {
        render : function(item, $container){

            commonRenderer.setContext($container);
            
            _renderer.load(function(){
                
                $container.append(item.render(this));
                item.postRender({}, '', this);
                
            }, item.getUsedClasses());
            
        },
        get : function(){
            return _renderer;
        },
        setOption : function(name, value){
            _renderer.setOption(name, value);
        },
        setOptions : function(options){
            _renderer.setOptions(options);
        },
        setContext : function($context){
            _$previousContext = $context;
            commonHelper.setContext($context);
        },
        restoreContext : function(){
             commonHelper.setContext(_$previousContext);
             _$previousContext = null;
        }    
    };

    return commonRenderer;

});

define("json!taoQtiItem/qtiCreator/editor/resources/device-list.json", function(){ return {"tablets":{"193986c3715c81838870f908fa98d69a":{"label":"Amazon Kindle Fire HDX 7\u2033","width":1920,"height":1200},"4e8eafab11aad1486992d7ee2c8c16ca":{"label":"Apple iPad","width":1024,"height":768},"5aac2932d9ad00d6d8a1604b8f9e4e8d":{"label":"Google Nexus 10, Motorola Xoom, Xyboard","width":1280,"height":800},"9805d9753ad08c7630a9ee5418aa6c6c":{"label":"Google Nexus 7","width":966,"height":604},"d4a431cedf4705d6bf2cba6d5788378b":{"label":"Samsung Galaxy Tab 7.7, 8.9, 10.1","width":1280,"height":800}},"phones":{"1b89338531ef0155c8d6abc2ac02c81a":{"label":"Apple iPhone 3GS","width":320,"height":480,"scaleFactor":1,"dpWidth":320,"dpHeight":480},"3f89da99d84214cde7df87ebe0699a6f":{"label":"Apple iPhone 4","width":640,"height":960,"scaleFactor":2,"dpWidth":320,"dpHeight":1920},"0d36971a5b98b367f54ced708c9af849":{"label":"Apple iPhone 5","width":640,"height":1136,"scaleFactor":2,"dpWidth":320,"dpHeight":2272},"026beffcc051af995660ebdede986ace":{"label":"BlackBerry Z10","width":768,"height":1280,"scaleFactor":2,"dpWidth":384,"dpHeight":2560},"fd2dd53e667d6d49e4fa73356fa941dd":{"label":"BlackBerry Z30","width":720,"height":1280,"scaleFactor":2,"dpWidth":360,"dpHeight":2560},"707584c1ae17d9b5b2cbe8603c91c147":{"label":"Google Nexus 4","width":768,"height":1280,"scaleFactor":2,"dpWidth":384,"dpHeight":2560},"91823264de952e7f2347e07db5c4058b":{"label":"Google Nexus 5","width":1080,"height":1920,"scaleFactor":3,"dpWidth":360,"dpHeight":5760},"cd69817a6e147e8a4677389e56fcf568":{"label":"Google Nexus S","width":480,"height":800,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1200},"75994faa6a38e31e99b53fcd75534a33":{"label":"HTC Evo, Touch HD, Desire HD, Desire","width":480,"height":800,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1200},"0cab4dfccdfc880687cb608cfe4159db":{"label":"HTC One X, EVO LTE","width":720,"height":1280,"scaleFactor":2,"dpWidth":360,"dpHeight":2560},"c4ff41fcba24d74fc21dc3490ca1edc9":{"label":"HTC Sensation, Evo 3D","width":540,"height":960,"scaleFactor":1.5,"dpWidth":360,"dpHeight":1440},"fa969a5e0dd2de53700eeee4ba4ba142":{"label":"LG Optimus 2X, Optimus 3D, Optimus Black","width":480,"height":800,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1200},"33c4f9364e295ec03531f3a3425819cf":{"label":"LG Optimus G","width":768,"height":1280,"scaleFactor":2,"dpWidth":384,"dpHeight":2560},"bc47f5275f0efd56fee52d43a8082981":{"label":"LG Optimus LTE, Optimus 4X HD","width":720,"height":1280,"scaleFactor":1.7,"dpWidth":424,"dpHeight":2176},"0732887e6e324fd10777b735520a34cf":{"label":"LG Optimus One","width":320,"height":480,"scaleFactor":1.5,"dpWidth":213,"dpHeight":720},"2e38a78364f09d0da0e9e1a3a68e7fb0":{"label":"Motorola Defy, Droid, Droid X, Milestone","width":480,"height":854,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1281},"bd4b78dddc7c9625a4141a1b1ddabb87":{"label":"Motorola Droid 3, Droid 4, Droid Razr, Atrix 4G, Atrix 2","width":540,"height":960,"scaleFactor":1,"dpWidth":540,"dpHeight":960},"3bf1edf21cfa81006183d2b02974c84e":{"label":"Motorola Droid Razr HD","width":720,"height":1280,"scaleFactor":1,"dpWidth":720,"dpHeight":1280},"ab5a352e0e016b97dac986f06c394f55":{"label":"Nokia C5, C6, C7, N97, N8, X7","width":360,"height":640,"scaleFactor":1,"dpWidth":360,"dpHeight":640},"4826fb7d7257aeaac992ce699df41b3c":{"label":"Nokia Lumia 7X0, Lumia 8XX, Lumia 900, N800, N810, N900","width":480,"height":800,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1200},"0a691ab20add7c432200f8fa6527b488":{"label":"Samsung Galaxy Note","width":800,"height":1280,"scaleFactor":2,"dpWidth":400,"dpHeight":2560},"9c23ee31be29960fbac9e9bbfc2fc7b0":{"label":"Samsung Galaxy Note 3","width":1080,"height":1920,"scaleFactor":2,"dpWidth":540,"dpHeight":3840},"92177c0508c1d73905a58e2338f2a81f":{"label":"Samsung Galaxy Note II","width":720,"height":1280,"scaleFactor":2,"dpWidth":360,"dpHeight":2560},"5222b8866dc4cc606725e16ffcc0a783":{"label":"Samsung Galaxy S III, Galaxy Nexus","width":720,"height":1280,"scaleFactor":2,"dpWidth":360,"dpHeight":2560},"37c1541e2bd55cfd0f4073b0ccdf68b3":{"label":"Samsung Galaxy S, S II, W","width":480,"height":800,"scaleFactor":1.5,"dpWidth":320,"dpHeight":1200},"2f7f64b7dda0144907ff300e83eed465":{"label":"Samsung Galaxy S4","width":1080,"height":1920,"scaleFactor":3,"dpWidth":360,"dpHeight":5760},"9c24f9057744dad56043702a9703127f":{"label":"Sony Xperia S, Ion","width":720,"height":1280,"scaleFactor":2,"dpWidth":360,"dpHeight":2560},"0a8b2732a016a9395c3af5f12dd9c0da":{"label":"Sony Xperia Sola, U","width":480,"height":854,"scaleFactor":1,"dpWidth":480,"dpHeight":854},"5a153d7f53d82dcb0801f041574a6a43":{"label":"Sony Xperia Z, Z1","width":1080,"height":1920,"scaleFactor":3,"dpWidth":360,"dpHeight":5760}},"screens":{"9e523ae15b61dc766f5c818726881ecf":{"label":"1920 \u00d7 1080","width":1920,"height":1080,"dpWidth":1920,"dpHeight":1080,"scaleFactor":1},"07769cd8d0a7d09818b2f0b018042fb7":{"label":"1366 \u00d7 768","width":1366,"height":768,"dpWidth":1366,"dpHeight":768,"scaleFactor":1},"72d5478a24194f98b9378e8e0fd65737":{"label":"1280 \u00d7 1024","width":1280,"height":1024,"dpWidth":1280,"dpHeight":1024,"scaleFactor":1},"b7a6dd5900cc72e61f0d3479c7e314ec":{"label":"1280 \u00d7 800","width":1280,"height":800,"dpWidth":1280,"dpHeight":800,"scaleFactor":1},"43193b0ff671a37d8232ab664190a125":{"label":"1024 \u00d7 768","width":1024,"height":768,"dpWidth":1024,"dpHeight":768,"scaleFactor":1},"c29e48814af5443ff5688d9e967ce917":{"label":"800 \u00d7 600","width":800,"height":600,"dpWidth":800,"dpHeight":600,"scaleFactor":1}}};});

define('taoQtiItem/qtiCreator/editor/preview',[
    'jquery',
    'i18n',
    'taoQtiItem/qtiCreator/helper/commonRenderer',
    'json!taoQtiItem/qtiCreator/editor/resources/device-list.json',
    'select2'
], function ($, __, commonRenderer, deviceList) {
    'use strict'

    var overlay,
        container,
        togglersByTarget = {},
        currOrientation = 'landscape',
        currPreviewType = 'desktop',
        $doc = $(document);

    /**
     *
     * @returns {boolean}
     */
    var createWidget = function (item) {

        if (!!overlay && overlay.length) {
            return false;
        }

        /**
         * Create an item on the toolbar
         *
         * @param tool
         * @param type
         * @returns {void|*}
         */
        var createTool = function (tool, type) {
            return $('<li>', {
                class: (type ? 'lft ' + type + '-only' : 'lft')
            }).append(tool);
        };

        /**
         * creates list of devices from devices.json
         *
         * @returns {*|HTMLElement}
         */
        var createDeviceSelector = function (type) {
            var device,
                devices,
                option,
                select = $('<select>', {
                    class: type + '-device-selector'
                });


            /*
             * @todo
             * The device list is currently based on the devices found on the Chrome emulator.
             * This is not ideal and should be changed in the future.
             * I have http://en.wikipedia.org/wiki/List_of_displays_by_pixel_density in mind but we
             * will need to figure what criteria to apply when generating the list.
            */
            switch (type) {
                case 'mobile':
                    devices = deviceList['tablets'];
                    break;
                case 'desktop':
                    devices = deviceList['screens'];
                    break;
            }

            for (device in devices) {
                if (devices.hasOwnProperty(device)) {
                    option = $('<option>', {
                        value: [devices[device].width, devices[device].height].join(','),
                        text: devices[device].label
                    });
                    if (currPreviewType === devices[device].label) {
                        option.prop('selected', true);
                    }
                    select.append(option);
                }
            }

            select.on('change', function() {
                var elem = $(this),
                    val = elem.val().split(','),
                    animationSettings,
                    i = val.length,
                    container = $('.' + type + '-preview-container');


                while (i--) {
                    val[i] = parseFloat(val[i]);
                }

                if (type === 'mobile' && currOrientation === 'portrait') {
                    animationSettings = {
                        width: val[1],
                        height: val[0]
                    };
                }
                else {
                    animationSettings = {
                        width: val[0],
                        height: val[1]
                    };
                }

                if (animationSettings.width === container.width()
                    && animationSettings.height === container.height()) {
                    return false;
                }

                container.animate(animationSettings, function () {
                    currPreviewType = type;
                });
            });

            return select;
        };

        /**
         * Change orientation of the tablet preview
         *
         * @returns {*|HTMLElement}
         */
        var createOrientationSelector = function (mobilePreviewContainer) {

            mobilePreviewContainer = mobilePreviewContainer.find('.preview-container');

            var select = $('<select>', {
                    class: 'mobile-orientation-selector'
                }),
                orientations = {
                    landscape: __('Landscape'),
                    portrait: __('Portrait')
                },
                orientation,
                option;
            for (orientation in orientations) {
                if (orientations.hasOwnProperty(orientation)) {
                    option = $('<option>', {
                        value: orientation,
                        text: orientations[orientation]
                    });
                    if (currOrientation === orientation) {
                        option.prop('selected', true);
                    }
                    select.append(option);
                }
            }
            select.on('change', function () {
                var newOrientation = $(this).val(),
                    animationSettings,
                    mobilePreviewFrame = $('.preview-mobile-frame');

                if (newOrientation === currOrientation) {
                    return false;
                }

                animationSettings = {
                    height: mobilePreviewContainer.width(),
                    width: mobilePreviewContainer.height()
                };

                mobilePreviewContainer.animate(animationSettings, function () {
                    mobilePreviewFrame.removeClass('mobile-preview-' + currOrientation)
                        .addClass('mobile-preview-' + newOrientation);

                    // reset global orientation
                    currOrientation = newOrientation;
                });

            });
            return select;
        };

        /**
         * The little warning at the very top
         *
         * @returns {*|HTMLElement}
         */
        var createFeedback = function () {
            var feedback = $('<div>', {
                class: 'tbl-cell'
            });
            feedback.append($('<div>', {
                class: 'feedback-info small',
                html: '<span class="icon-info"/>' + __('Final rendering may differ from this preview!')
            }));
            return feedback;
        };

        /**
         * Create container for item
         *
         * @param type
         * @returns {*|HTMLElement}
         */
        var createPreviewFrame = function (type) {
            var previewFrame = $('<div>', {
                class: type + '-preview-frame ' + type + '-only preview-outer-frame'
            });
            var previewContainer = $('<div>', {
                class: type + '-preview-container preview-container'
            });
            if (type === 'mobile') {
                previewFrame.addClass('mobile-preview-' + currOrientation);
            }
            previewFrame.append(previewContainer);
            return previewFrame;
        };

        /**
         * Toggle between mobile and desktop
         *
         * @param type
         * @returns {*}
         */
        var createToggler = function (type) {
            var toggler,
                toggleText,
                toggleTarget,
                icon;

            // view togglers
            if (type === 'mobile') {
                toggleText = __('Switch to desktop');
                toggleTarget = 'desktop';
                icon = 'icon-desktop-preview';
            }
            else {
                toggleText = __('Switch to mobile');
                toggleTarget = 'mobile';
                icon = 'icon-mobile-preview';
            }


            toggler = $('<span>', {
                class: 'btn-info toggle-view small',
                html: '<span class="' + icon + '"/>' + toggleText
            }).prop('target', toggleTarget);

            toggler.on('click', function () {
                var target = $(this).prop('target'),
                    newClass = 'preview-' + target,
                    oldClass = newClass === 'preview-desktop' ? 'preview-mobile' : 'preview-desktop',
                    targetContainer =  $('.' + target + '-preview-container');

                overlay.removeClass(oldClass).addClass(newClass);
                currPreviewType = target;
                targetContainer.empty();
                commonRenderer.render(item, targetContainer);
            });

            // add toggler to global collection
            togglersByTarget[toggleTarget] = toggler;

            return toggler;
        };

        /**
         * Close preview
         *
         * @returns {*|HTMLElement}
         */
        var createCloser = function () {
            var closer = $('<span>', {
                class: 'btn-info small',
                html: __('Close') + ' <span class="icon-close r"/>'
            });
            closer.on('click', function () {
                commonRenderer.setContext($('.item-editor-item'));
                overlay.fadeOut();
            });
            return closer;
        };

        /**
         * Heading, i.e. Desktop preview|Mobile preview
         * @param type
         * @returns {*|HTMLElement}
         */
        var createPreviewHeading = function (type) {

            return $('<h1>', {
                class: type + '-preview-heading ' + type + '-only preview-heading tbl-cell',
                text: (type === 'mobile') ? __('Mobile Preview') : __('Desktop Preview')
            });
        };

        /**
         * Build the whole shebang
         */
        (function () {
            var types = ['mobile', 'desktop'],
                iT = types.length,
                previews = {},
                headings = {},
                form = $('<form>', {
                    class: 'preview-utility-bar plain',
                    autocomplete: 'off'
                }),
                formInner = $('<div>', {
                    class: 'preview-utility-bar-inner tbl'
                }),
                canvas = $('<div>', {
                    class: 'preview-canvas'
                }),
                feedback = createFeedback(),
                deviceSelectors = {},
                orientationSelector,
                viewTogglers = {},
                tools = $('<ul>', {
                    class: 'plain tbl-cell clearfix'
                }),
                closer = createCloser();

            overlay = $('<div>', {
                class: 'preview-overlay tao-scope overlay preview-' + currPreviewType
            });
            container = $('<div>', {
                class: 'preview-container-outer'
            });


            while (iT--) {
                previews[types[iT]] = createPreviewFrame(types[iT]);
                viewTogglers[types[iT]] = createToggler(types[iT]);
                deviceSelectors[types[iT]] = createDeviceSelector(types[iT]);
                headings[types[iT]] = createPreviewHeading(types[iT]);
                formInner.append(headings[types[iT]]);
            }

            orientationSelector = createOrientationSelector(previews['mobile']);

            tools.append(createTool(deviceSelectors['desktop'], 'desktop'));
            tools.append(createTool(viewTogglers['desktop'], 'desktop'));

            tools.append(createTool(deviceSelectors['mobile'], 'mobile'));
            tools.append(createTool(orientationSelector, 'mobile'));
            tools.append(createTool(viewTogglers['mobile'], 'mobile'));

            tools.append(createTool(closer, false));

            formInner.append(feedback);
            formInner.append(tools);

            form.append(formInner);

            canvas.append(form);
            canvas.append(previews['desktop']);
            canvas.append(previews['mobile']);

            container.append(canvas);

            overlay.append(container);

            overlay.find('select').select2({
                minimumResultsForSearch: -1
            });

            $doc.find('body').append(overlay);

            overlay.hide();

            $doc.keyup(function (e) {
                if (e.keyCode == 27) {
                    closer.trigger('click');
                }
            });
        })();

        return container;
    };


    return (function ($) {


        /**
         * Create preview
         *
         * @param launchers - buttons to launch preview
         * @param item
         */
        var init = function (launchers, item) {

            createWidget(item);

            $(launchers).on('click', function () {
                currPreviewType = $(this).data('preview-type') || 'desktop';

                if (togglersByTarget[currPreviewType]) {
                    togglersByTarget[currPreviewType].trigger('click');
                }

                overlay.fadeIn(function () {
                    overlay.height($doc.outerHeight());
                    overlay.find('select').trigger('change');
                });
            });
        };

        return {
            init: init
        }
    }($));
});
define('taoQtiItem/qtiCreator/editor/preparePrint',[
    'jquery'
], function ($) {
    'use strict'

    /**
     * Prepare item for printing.
     *
     * @author <a href="mailto:dieter@taotesting.com">Dieter Raber</a>
     */
    var preparePrint = function () {

        function initHideOnPrint(elem) {
            elem.siblings().each(function () {
                $(this).addClass('item-no-print');
            });
            return elem.parent();
        }

        var parent = initHideOnPrint($('#item-editor-scope').parent());
        while (parent.length && parent.get(0).nodeName.toLowerCase() !== 'body') {
            parent = initHideOnPrint(parent);
        }

        $('#item-editor-toolbar, .item-editor-sidebar').addClass('item-no-print');
    };

    $('#print-trigger').on('click', function () {
        window.print();
    });

    return preparePrint;
});



define('taoQtiItem/qtiItem/core/qtiClasses',[], function(){
    return {
        '_container' : 'taoQtiItem/qtiItem/core/Container',
        'assessmentItem' : 'taoQtiItem/qtiItem/core/Item',
        'responseProcessing' : 'taoQtiItem/qtiItem/core/ResponseProcessing',
        '_simpleFeedbackRule' : 'taoQtiItem/qtiItem/core/response/SimpleFeedbackRule',
        'stylesheet' : 'taoQtiItem/qtiItem/core/Stylesheet',
        'math' : 'taoQtiItem/qtiItem/core/Math',
        'img' : 'taoQtiItem/qtiItem/core/Img',
        'object' : 'taoQtiItem/qtiItem/core/Object',
        'outcomeDeclaration' : 'taoQtiItem/qtiItem/core/variables/OutcomeDeclaration',
        'responseDeclaration' : 'taoQtiItem/qtiItem/core/variables/ResponseDeclaration',
        'rubricBlock' : 'taoQtiItem/qtiItem/core/RubricBlock',
        'associableHotspot' : 'taoQtiItem/qtiItem/core/choices/AssociableHotspot',
        'gap' : 'taoQtiItem/qtiItem/core/choices/Gap',
        'gapImg' : 'taoQtiItem/qtiItem/core/choices/GapImg',
        'gapText' : 'taoQtiItem/qtiItem/core/choices/GapText',
        'hotspotChoice' : 'taoQtiItem/qtiItem/core/choices/HotspotChoice',
        'hottext' : 'taoQtiItem/qtiItem/core/choices/Hottext',
        'inlineChoice' : 'taoQtiItem/qtiItem/core/choices/InlineChoice',
        'simpleAssociableChoice' : 'taoQtiItem/qtiItem/core/choices/SimpleAssociableChoice',
        'simpleChoice' : 'taoQtiItem/qtiItem/core/choices/SimpleChoice',
        'associateInteraction' : 'taoQtiItem/qtiItem/core/interactions/AssociateInteraction',
        'choiceInteraction' : 'taoQtiItem/qtiItem/core/interactions/ChoiceInteraction',
        'endAttemptInteraction' : 'taoQtiItem/qtiItem/core/interactions/EndAttemptInteraction',
        'extendedTextInteraction' : 'taoQtiItem/qtiItem/core/interactions/ExtendedTextInteraction',
        'gapMatchInteraction' : 'taoQtiItem/qtiItem/core/interactions/GapMatchInteraction',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiItem/core/interactions/GraphicAssociateInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiItem/core/interactions/GraphicGapMatchInteraction',
        'graphicOrderInteraction' : 'taoQtiItem/qtiItem/core/interactions/GraphicOrderInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiItem/core/interactions/HotspotInteraction',
        'hottextInteraction' : 'taoQtiItem/qtiItem/core/interactions/HottextInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiItem/core/interactions/InlineChoiceInteraction',
        'matchInteraction' : 'taoQtiItem/qtiItem/core/interactions/MatchInteraction',
        'mediaInteraction' : 'taoQtiItem/qtiItem/core/interactions/MediaInteraction',
        'orderInteraction' : 'taoQtiItem/qtiItem/core/interactions/OrderInteraction',
        'prompt' : 'taoQtiItem/qtiItem/core/interactions/Prompt',
        'selectPointInteraction' : 'taoQtiItem/qtiItem/core/interactions/SelectPointInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiItem/core/interactions/SliderInteraction',
        'textEntryInteraction' : 'taoQtiItem/qtiItem/core/interactions/TextEntryInteraction',
        'uploadInteraction' : 'taoQtiItem/qtiItem/core/interactions/UploadInteraction',
        'feedbackBlock' : 'taoQtiItem/qtiItem/core/feedbacks/FeedbackBlock',
        'feedbackInline' : 'taoQtiItem/qtiItem/core/feedbacks/FeedbackInline',
        'modalFeedback' : 'taoQtiItem/qtiItem/core/feedbacks/ModalFeedback'
    };
});
//@todo : move this to the ../helper directory
define('taoQtiItem/qtiItem/core/Loader',['lodash', 'class', 'taoQtiItem/qtiItem/core/qtiClasses', 'taoQtiItem/qtiItem/core/Element'], function(_, Class, qtiClasses, Element){

    var Loader = Class.extend({
        init : function(item, classesLocation){

            this.qti = {}; //loaded qti classes are store here
            this.classesLocation = {};

            this.item = item || null;//starts either from scratch or with an existing item object
            this.setClassesLocation(classesLocation || qtiClasses);//load default location for qti classes model
        },
        setClassesLocation : function(qtiClasses){
            _.extend(this.classesLocation, qtiClasses);
            return this;
        },
        getRequiredClasses : function(data){
            var ret = [];
            for(var i in data){
                if(i === 'qtiClass' && data[i] !== '_container' && i !== 'relatedItem'){//although a _container is a concrete class in TAO, it is not defined in QTI standard
                    ret.push(data[i]);
                }else if(typeof(data[i]) === 'object'){
                    ret = _.union(ret, this.getRequiredClasses(data[i]));
                }
            }
            return ret;
        },
        loadRequiredClasses : function(data, callback, reload){

            var requiredClasses = this.getRequiredClasses(data, reload), required = [];

            for(var i in requiredClasses){
                var requiredClass = requiredClasses[i];
                if(this.classesLocation[requiredClass]){
                    required.push(this.classesLocation[requiredClass]);
                }else{
                    debugger;
                    throw new Error('missing qti class location declaration : ' + requiredClass);
                }
            }

            var _this = this;
            require(required, function(){
                _.each(arguments, function(QtiClass){
                    _this.qti[QtiClass.prototype.qtiClass] = QtiClass;
                });
                callback.call(_this, _this.qti);
            });
        },
        getLoadedClasses : function(){
            return _.keys(this.qti);
        },
        loadItemData : function(data, callback){

            var _this = this;
            _this.loadRequiredClasses(data, function(Qti){

                if(typeof(data) === 'object' && data.qtiClass === 'assessmentItem'){
                    _this.item = new Qti.assessmentItem(data.serial, data.attributes || {});
                    _this.loadContainer(_this.item.getBody(), data.body);

                    for(var i in data.outcomes){
                        var outcome = _this.buildOutcome(data.outcomes[i]);
                        if(outcome){
                            _this.item.addOutcomeDeclaration(outcome);
                        }
                    }
                    for(var i in data.feedbacks){
                        var feedback = _this.buildElement(data.feedbacks[i]);
                        if(feedback){
                            _this.item.addModalFeedback(feedback);
                        }
                    }
                    for(var i in data.stylesheets){
                        var stylesheet = _this.buildElement(data.stylesheets[i]);
                        if(stylesheet){
                            _this.item.addStylesheet(stylesheet);
                        }
                    }

                    //important : build responses after all modal feedbacks and outcomes has been loaded, because the simple feedback rules need to reference them
                    for(var i in data.responses){
                        var response = _this.buildResponse(data.responses[i]);
                        if(response){
                            _this.item.addResponseDeclaration(response);

                            var feedbackRules = data.responses[i].feedbackRules;
                            if(feedbackRules){
                                _.forIn(feedbackRules, function(fbData, serial){
                                    response.feedbackRules[serial] = _this.buildSimpleFeedbackRule(fbData);
                                });
                            }
                        }
                    }

                    if(data.responseProcessing){
                        _this.item.setResponseProcessing(_this.buildResponseProcessing(data.responseProcessing));
                    }
                    _this.item.setNamespaces(data.namespaces);
                }

                if(typeof(callback) === 'function'){
                    callback.call(_this, _this.item);
                }
            });
        },
        loadElement : function(data, callback){

            var _this = this;

            _this.loadRequiredClasses(data, function(Qti){

                var element = _this.buildElement(data);

                if(typeof(callback) === 'function'){
                    callback.call(_this, element);
                }
            });
        },
        /**
         * Load ALL given elements into existing loaded item 
         * 
         * @todo to be renamed to loadItemElements
         * @param {object} data
         * @param {function} callback
         * @returns {undefined}
         */
        loadElements : function(data, callback){

            var _this = this;

            if(_this.item){

                this.loadRequiredClasses(data, function(){

                    var allElements = _this.item.getComposingElements();

                    for(var i in data){
                        var elementData = data[i];
                        if(elementData && elementData.qtiClass && elementData.serial){
                            //find and update element
                            if(allElements[elementData.serial]){
                                _this.loadElementData(allElements[elementData.serial], elementData);
                            }
                        }
                    }

                    if(typeof(callback) === 'function'){
                        callback.call(_this, _this.item);
                    }
                });
            }else{
                throw 'QtiLoader : cannot load elements in empty item';
            }

        },
        buildResponse : function(data){

            var response = this.buildElement(data);

            response.template = data.howMatch || null;
            response.defaultValue = data.defaultValue || null;
            response.correctResponse = data.correctResponses || null;
            
            if(_.size(data.mapping)){
                response.mapEntries = data.mapping;
            }else if(_.size(data.areaMapping)){
                response.mapEntries = data.areaMapping;
            }else{
                response.mapEntries = {};
            }
            
            response.mappingAttributes = data.mappingAttributes || {};

            return response;
        },
        buildSimpleFeedbackRule : function(data){

            var feedbackRule = this.buildElement(data);

            if(data.condition){
                feedbackRule.condition = data.condition;
            }
            if(data.comparedValue){
                feedbackRule.comparedValue = data.comparedValue;
            }

            feedbackRule.comparedOutcome = this.item.responses[data.comparedOutcome] || null;
            feedbackRule.feedbackOutcome = this.item.outcomes[data.feedbackOutcome] || null;
            feedbackRule.feedbackThen = this.item.modalFeedbacks[data.feedbackThen] || null;
            feedbackRule.feedbackElse = this.item.modalFeedbacks[data.feedbackElse] || null;

            return feedbackRule;
        },
        buildOutcome : function(data){
            var outcome = this.buildElement(data);
            outcome.defaultValue = data.defaultValue || null;
            return outcome;
        },
        buildResponseProcessing : function(data){
            var rp = this.buildElement(data);
            if(data && data.processingType){
                if(data.processingType === 'custom'){
                    rp.xml = data.data;
                    rp.processingType = 'custom';
                }else{
                    rp.processingType = 'templateDriven';
                }
            }
            return rp;
        },
        loadContainer : function(bodyObject, bodyData){
            if(!Element.isA(bodyObject, '_container')){
                throw 'bodyObject must be a QTI Container';
            }

            if(bodyData && typeof bodyData.body === 'string' && (typeof bodyData.elements === 'array' || typeof bodyData.elements === 'object')){
                for(var serial in bodyData.elements){
                    var eltData = bodyData.elements[serial];
                    //check if class is loaded:
                    var element = this.buildElement(eltData);
                    if(element){
                        bodyObject.setElement(element, bodyData.body);
                    }
                }
                bodyObject.body(bodyData.body);
            }else{
                throw 'wrong bodydata format';
            }
        },
        buildElement : function(elementData){
            var elt = null;
            if(elementData && elementData.qtiClass && elementData.serial){
                var className = elementData.qtiClass;
                if(this.qti[className]){
                    elt = new this.qti[className](elementData.serial);
                    this.loadElementData(elt, elementData);
                }else{
                    throw 'the qti element class does not exist: ' + className;
                }
            }else{
                throw 'wrong elementData format';
            }
            return elt;
        },
        loadElementData : function(element, data){

            element.setAttributes(_.clone(data.attributes) || {});

            if(element.body && data.body){
                if(element.bdy){
                    this.loadContainer(element.getBody(), data.body);
                }
            }

            if(element.object && data.object){
                if(element.object){
                    this.loadObjectData(element.object, data.object);
                }
            }

            if(Element.isA(element, 'interaction')){
                this.loadInteractionData(element, data);
            }else if(Element.isA(element, 'choice')){
                this.loadChoiceData(element, data);
            }else if(Element.isA(element, 'math')){
                this.loadMathData(element, data);
            }

            return element;
        },
        loadInteractionData : function(interaction, data){
            if(Element.isA(interaction, 'blockInteraction')){
                if(data.prompt){
                    this.loadContainer(interaction.prompt.getBody(), data.prompt);
                }
            }
            this.buildInteractionChoices(interaction, data);
        },
        buildInteractionChoices : function(interaction, data){

            //note: Qti.ContainerInteraction (Qti.GapMatchInteraction and Qti.HottextInteraction) has already been parsed by builtElement(interacionData);
            if(data.choices){
                if(Element.isA(interaction, 'matchInteraction')){
                    for(var set = 0; set < 2; set++){
                        if(!data.choices[set]){
                            throw 'missing match set #' + set;
                        }
                        var matchSet = data.choices[set];
                        for(var serial in matchSet){
                            var choice = this.buildElement(matchSet[serial]);
                            if(choice){
                                interaction.addChoice(choice, set);
                            }
                        }
                    }
                }else{
                    for(var serial in data.choices){
                        var choice = this.buildElement(data.choices[serial]);
                        if(choice){
                            interaction.addChoice(choice);
                        }
                    }
                }

                if(Element.isA(interaction, 'graphicGapMatchInteraction')){
                    if(data.gapImgs){
                        for(var serial in data.gapImgs){
                            var gapImg = this.buildElement(data.gapImgs[serial]);
                            if(gapImg){
                                interaction.addGapImg(gapImg);
                            }
                        }
                    }
                }

            }

        },
        loadChoiceData : function(choice, data){
            if(Element.isA(choice, 'textVariableChoice')){
                choice.val(data.text);
            }else if(Element.isA(choice, 'gapImg')){
                //has already been taken care of in buildElement()
            }else if(Element.isA(choice, 'containerChoice')){
                //has already been taken care of in buildElement()
            }
        },
        loadObjectData : function(object, data){
            object.setAttributes(data.attributes);
            //@todo: manage object like a container
            if(data.alt){
                if(data.alt.qtiClass && data.alt.qtiClass === 'object'){
                    object.alt = data.alt;
                }
            }
        },
        loadMathData : function(math, data){
            math.ns = data.ns || {};
            math.setMathML(data.mathML || '');
            math.annotations = data.annotations || {};
        }
    });

    return Loader;
});
define('taoQtiItem/qtiCreator/model/helper/event',['jquery', 'taoQtiItem/qtiItem/core/Element'], function($, Element){

    return {
        choiceCreated : function(choice, interaction){
            $(document).trigger('choiceCreated.qti-widget', {choice : choice, interaction : interaction});
        },
        deleted : function(element, parent){
            Element.unsetElement(element.getSerial());
            $(document).off('.' + element.getSerial());
            $(document).trigger('deleted.qti-widget', {element : element, parent : parent});
        }
    }
});
define('taoQtiItem/qtiCreator/model/mixin/editable',[
    'lodash',
    'jquery',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiCreator/model/helper/event'
], function(_, $, Element, event){

    var _removeSelf = function(element){
        
        var removed = false,
            item = element.getRelatedItem();

        if(item){
            
            var found = item.find(element.getSerial());
            if(found){
                
                var parent = found.parent;
                if(Element.isA(parent, 'interaction') && Element.isA(element, 'choice')){
                    parent.removeChoice(element);
                    removed = true;
                }else if(typeof parent.initContainer === 'function' && found.location === 'body'){
                    parent.getBody().removeElement(element);
                    removed = true;
                }

                if(removed){
                    event.deleted(element, parent);
                }
            }
        }else{
            throw 'no related item found';
        }

        return removed;
    };
    
    var _removeElement = function(element, containerPropName, eltToBeRemoved){

        if(element[containerPropName]){
            var serial = '';
            if(typeof(eltToBeRemoved) === 'string'){
                serial = eltToBeRemoved;
            }else if(eltToBeRemoved instanceof Element){
                serial = eltToBeRemoved.getSerial();
            }
            if(serial){
                delete element[containerPropName][serial];
                Element.unsetElement(serial);
            }
        }

        return element;
    };
    
    var methods = {
        init : function(serial, attributes){

            //init call in the format init(attributes)
            if(typeof(serial) === 'object'){
                attributes = serial;
                serial = '';
            }

            var attr = {};

            if(_.isFunction(this.getDefaultAttributes)){
                _.extend(attr, this.getDefaultAttributes());
            }
            _.extend(attr, attributes);

            this._super(serial, attr);
        },
        attr : function(key, value){
            var ret = this._super(key, value);
            if(key !== undefined && value !== undefined){
                $(document).trigger('attributeChange.qti-widget', {'element' : this, 'key' : key, 'value' : value});
            }
            return ret;
        },
        remove : function(){
            if(arguments.length === 0){
                return _removeSelf(this);
            }else if(arguments.length === 2){
                return _removeElement(this, arguments[0], arguments[1]);
            }else{
                throw 'invalid number of argument given';
            }
        }        
    };

    return methods;
});
/**
 * Define the location of all qti classes used in the QTI Creator
 */
define('taoQtiItem/qtiCreator/model/qtiClasses',['lodash', 'taoQtiItem/qtiItem/core/qtiClasses'], function(_, qtiClasses){
    
    //clone the qtiClasses instead of modifying it by direct extend:
    return _.defaults({
        'assessmentItem' : 'taoQtiItem/qtiCreator/model/Item',
        '_container' : 'taoQtiItem/qtiCreator/model/Container',
        'img' : 'taoQtiItem/qtiCreator/model/Img',
        'math' : 'taoQtiItem/qtiCreator/model/Math',
        'rubricBlock' : 'taoQtiItem/qtiCreator/model/RubricBlock',
        'modalFeedback' : 'taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback',
        'choiceInteraction' : 'taoQtiItem/qtiCreator/model/interactions/ChoiceInteraction',
        'orderInteraction' : 'taoQtiItem/qtiCreator/model/interactions/OrderInteraction',
        'associateInteraction' : 'taoQtiItem/qtiCreator/model/interactions/AssociateInteraction',
        'matchInteraction' : 'taoQtiItem/qtiCreator/model/interactions/MatchInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiCreator/model/interactions/InlineChoiceInteraction',
        'simpleChoice' : 'taoQtiItem/qtiCreator/model/choices/SimpleChoice',
        'simpleAssociableChoice' : 'taoQtiItem/qtiCreator/model/choices/SimpleAssociableChoice',
        'inlineChoice' : 'taoQtiItem/qtiCreator/model/choices/InlineChoice',
        'mediaInteraction' : 'taoQtiItem/qtiCreator/model/interactions/MediaInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCreator/model/interactions/SliderInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiCreator/model/interactions/HotspotInteraction',
        'selectPointInteraction' : 'taoQtiItem/qtiCreator/model/interactions/SelectPointInteraction',
        'graphicInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicOrderInteraction',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicAssociateInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicGapMatchInteraction',
        'hotspotChoice' : 'taoQtiItem/qtiCreator/model/choices/HotspotChoice',
        'responseDeclaration' : 'taoQtiItem/qtiCreator/model/variables/ResponseDeclaration',
        'responseProcessing' : 'taoQtiItem/qtiCreator/model/ResponseProcessing'
    }, qtiClasses);

});

define('taoQtiItem/qtiCreator/model/helper/container',['lodash', 'taoQtiItem/qtiCreator/model/qtiClasses'], function(_, qtiClasses){

    var methods = {
        createElements : function(container, body, callback){
            
            var regex = /{{([a-z0-9_]*):new}}/ig;

            //first pass to get required qti classes, but do not replace
            var required = {};
            body.replace(regex,
                function(original, qtiClass){
                    if(qtiClasses[qtiClass]){
                        required[qtiClass] = qtiClasses[qtiClass];
                    }else{
                        throw 'missing required class : ' + qtiClass;
                    }
                });

            //second pass after requiring classes:
            require(_.values(required), function(){

                //register and name all loaded classes:
                var Qti = {};
                for(var i in arguments){
                    Qti[arguments[i].prototype.qtiClass] = arguments[i];
                }

                //create new elements
                var newElts = {};
                var newBody = body.replace(regex,
                    function(original, qtiClass){
                        if(Qti[qtiClass]){
                            //create new element
                            var elt = new Qti[qtiClass]();
                            if(container.getRenderer()){
                                elt.setRenderer(container.getRenderer());
                            }
                            newElts[elt.getSerial()] = elt;
                            return elt.placeholder();
                        }else{
                            return original;
                        }
                    });

                //insert them:    
                container.setElements(newElts, newBody);

                //operations after insertions:
                for(var i in newElts){
                    var elt = newElts[i];
                    if(typeof(elt.buildIdentifier) === 'function'){
                        elt.buildIdentifier();
                    }
                    if(typeof(elt.afterCreate) === 'function'){
                        elt.afterCreate();
                    }
                    $(document).trigger('elementCreated.qti-widget', {'parent' : container.parent(), 'element' : elt});
                }

                if(typeof(callback) === 'function'){
                    callback.call(container, newElts);
                }
            });

        }
    };

    return methods;
});
define('taoQtiItem/qtiCreator/model/mixin/editableContainer',['taoQtiItem/qtiCreator/model/helper/container'], function(containerHelper){

    var methods = {
        createElements : function(body, callback){
            
            var _this = this;
            containerHelper.createElements(_this.getBody(), body, function(newElts){
                callback.call(_this, newElts);
            });

        }
    };

    return methods;
});
define('taoQtiItem/qtiItem/core/IdentifiedElement',['taoQtiItem/qtiItem/core/Element'], function(Element){
    var IdentifiedElement = Element.extend({
        buildIdentifier : function(prefix, useSuffix){
            if(useSuffix === undefined){
                useSuffix = true;
            }
            var item = this.getRelatedItem();
            if(item){
                var suffix = '', i = 1, usedIds = item.getUsedIdentifiers();
                if(prefix){
                    prefix = prefix.replace(/_[0-9]+$/ig, '_'); //detect incremental id of type choice_12, response_3, etc.
                    prefix = prefix.replace(/[^a-zA-Z0-9_]/ig, '_');
                    prefix = prefix.replace(/(_)+/ig, '_');
                    if(useSuffix){
                        suffix = '_' + i;
                    }
                }else{
                    prefix = this.qtiClass;
                    suffix = '_' + i;
                }

                do{
                    var exists = false;
                    var id = prefix + suffix;
                    if(usedIds[id]){
                        exists = true;
                        suffix = '_' + i;
                        i++;
                    }
                }while(exists);

                this.attr('identifier', id);
            }else{
                throw 'cannot build identifier of an element that is not attached to an assessment item';
            }
            return this;
        },
        id : function(value){
            if(!value && !this.attr('identifier')){
                this.buildIdentifier(value);
            }
            return this.attr('identifier', value);
        }
    });

    return IdentifiedElement;
});


define('taoQtiItem/qtiItem/mixin/Mixin',[],function(){
    return {
        augment : function(targetClass, methods, options){
            if(typeof(targetClass) === 'function' && typeof(methods) === 'object'){
                for(var methodName in methods){
                    if(!Object.hasOwnProperty(targetClass.prototype, methodName)){
                        targetClass.prototype[methodName] = methods[methodName];
                    }else{
                        if(options && options.append){
                            var _parent = targetClass.prototype[methodName];
                            targetClass.prototype[methodName] = function(){
                                methods[methodName].apply(this, arguments);
                                return _parent.apply(this, arguments);
                            }
                        }
                    }
                }
            }
        }
    }
});
define('taoQtiItem/qtiItem/core/Container',['taoQtiItem/qtiItem/core/Element', 'lodash', 'jquery', 'taoQtiItem/qtiItem/helper/rendererConfig'], function(Element, _, $, rendererConfig){

    var Container = Element.extend({
        qtiClass : '_container',
        init : function(body){
            if(body && typeof body !== 'string'){
                throw 'the body of a container must be a string';
            }
            this.bdy = '';
            this.body(body || '');
            this.elements = {};
            this._super();//generate serial, attributes array always empty
        },
        body : function(body){
            if(typeof body === 'undefined'){
                return this.bdy;
            }else{
                if(typeof body === 'string'){
                    this.bdy = body;
                    $(document).trigger('containerBodyChange', {
                        body : body,
                        container : this
                    });
                }else{
                    throw 'body must be a string';
                }
            }
        },
        setElements : function(elements, body){
            var returnValue = false;

            for(var i in elements){
                var elt = elements[i];
                if(elt instanceof Element){

                    if(body.indexOf(elt.placeholder()) === -1){
                        body += elt.placeholder();//append the element if no placeholder found
                    }

                    elt.setRelatedItem(this.getRelatedItem() || null);
                    this.elements[elt.getSerial()] = elt;
                    $(document).trigger('containerElementAdded', {
                        element : elt,
                        container : this
                    });

                    returnValue = true;
                }else{
                    returnValue = false;
                    throw 'expected a qti element';
                }
            }

            this.body(body);

            return returnValue;
        },
        setElement : function(element, body){
            return this.setElements([element], body);
        },
        removeElement : function(element){
            var serial = '';
            if(typeof(element) === 'string'){
                serial = element;
            }else if(element instanceof Element){
                serial = element.getSerial();
            }
            delete this.elements[serial];
            this.body(this.body().replace('{{' + serial + '}}', ''));
            return this;
        },
        getElements : function(qtiClass){
            var elts = {};
            if(typeof(qtiClass) === 'string'){
                for(var serial in this.elements){
                    if(Element.isA(this.elements[serial], qtiClass)){
                        elts[serial] = this.elements[serial];
                    }
                }
            }else{
                //@todo : check dangerous passing by ref usage here:
                elts = this.elements;
            }
            return elts;
        },
        getElement : function(serial){
            return this.elements[serial] ? this.elements[serial] : null;
        },
        getComposingElements : function(){
            var elements = this.getElements();
            var elts = {};
            for(var serial in elements){
                elts[serial] = elements[serial];//pass individual object by ref, instead of the whole list(object)
                elts = _.extend(elts, elements[serial].getComposingElements());
            }
            return elts;
        },
        render : function(){

            var args = rendererConfig.getOptionsFromArguments(arguments),
                renderer = args.renderer || this.getRenderer(),
                elementsData = [],
                tpl = this.body();

            for(var serial in this.elements){
                var elt = this.elements[serial];
                if(typeof elt.render === 'function'){
                    if(elt.qtiClass === '_container'){
                        //@todo : container rendering merging, to be tested
                        tpl = tpl.replace(elt.placeholder(), elt.render(renderer));
                    }else{
                        tpl = tpl.replace(elt.placeholder(), '{{{' + serial + '}}}');
                        elementsData[serial] = elt.render(renderer);
                    }
                }else{
                    throw 'render() is not defined for the qti element: ' + serial;
                }
            }

            if(renderer.isRenderer){
                return this._super({
                    body : renderer.renderDirect(tpl, elementsData),
                    contentModel : this.contentModel || 'flow'
                }, renderer);
            }else{
                throw 'invalid qti renderer for qti container';
            }
        },
        postRender : function(data, altClassName, renderer){

            renderer = renderer || this.getRenderer();

            for(var serial in this.elements){
                var elt = this.elements[serial];
                if(typeof elt.postRender === 'function'){
                    elt.postRender(data, '', renderer);
                }
            }
            this._super(data, altClassName, renderer);
        },
        toArray : function(){
            var arr = {
                serial : this.serial,
                body : this.bdy,
                elements : {}
            };

            for(var serial in this.elements){
                arr.elements[serial] = this.elements[serial].toArray();
            }

            return arr;
        },
        find : function(serial, parent){

            var found = null;

            if(this.elements[serial]){
                
                found = {'parent' : parent || this, 'element' : this.elements[serial], 'location' : 'body'};
                
            }else{
                
                _.each(this.elements, function(elt){
                    
                    found = elt.find(serial);
                    if(found){
                        return false;//break loop
                    }
                });
            }

            return found;
        }
    });

    return Container;
});
define('taoQtiItem/qtiItem/mixin/Container',['taoQtiItem/qtiItem/mixin/Mixin', 'taoQtiItem/qtiItem/core/Container'], function(Mixin, Container){

    var methods = {
        initContainer : function(body){
            this.bdy = new Container(body || '');
            this.bdy.setRelatedItem(this.getRelatedItem() || null);
            this.bdy.contentModel = 'blockStatic';
        },
        getBody : function(){
            return this.bdy;
        },
        body : function(body){
            var ret = this.bdy.body(body);
            return (body) ? this : ret;//for method chaining on get
        },
        setElement : function(element, body){
            this.bdy.setElement(element, body);
            return this;
        },
        removeElement : function(element){
            return this.bdy.removeElement(element);
        }
    };

    return {
        augment : function(targetClass){
            Mixin.augment(targetClass, methods);
        },
        methods : methods
    };
});
define('taoQtiItem/qtiItem/mixin/ContainerItemBody',['taoQtiItem/qtiItem/mixin/Mixin', 'taoQtiItem/qtiItem/mixin/Container', 'lodash'], function(Mixin, Container, _){
    
    var methods = {};
    _.extend(methods, Container.methods);
    _.extend(methods, {
        initContainer:function(body){
            Container.methods.initContainer.call(this, body);
            this.bdy.contentModel = 'itemBody';
        }
    });

    return {
        augment : function(targetClass){
            Mixin.augment(targetClass, methods);
        },
        methods : methods
    };
});
define('taoQtiItem/qtiItem/core/Item',['taoQtiItem/qtiItem/core/Element', 'taoQtiItem/qtiItem/core/IdentifiedElement', 'taoQtiItem/qtiItem/mixin/ContainerItemBody', 'lodash'], function(Element, IdentifiedElement, Container, _){

    var Item = IdentifiedElement.extend({
        qtiClass : 'assessmentItem',
        init : function(serial, attributes){
            this._super(serial, attributes);
            this.relatedItem = this;
            this.stylesheets = {};
            this.responses = {};
            this.outcomes = {};
            this.modalFeedbacks = {};
            this.responseProcessing = null;
        },
        getInteractions : function(){
            var interactions = [];
            var elts = this.getComposingElements();
            for(var serial in elts){
                if(Element.isA(elts[serial], 'interaction')){
                    interactions.push(elts[serial]);
                }
            }
            return interactions;
        },
        addResponseDeclaration : function(response){
            if(Element.isA(response, 'responseDeclaration')){
                response.setRelatedItem(this);
                this.responses[response.getSerial()] = response;
            }else{
                throw 'is not a qti response declaration';
            }
            return this;
        },
        getResponseDeclaration : function(identifier){
            for(var i in this.responses){
                if(this.responses[i].attr('identifier') === identifier){
                    return this.responses[i];
                }
            }
            return null;
        },
        addOutcomeDeclaration : function(outcome){
            if(Element.isA(outcome, 'outcomeDeclaration')){
                outcome.setRelatedItem(this);
                this.outcomes[outcome.getSerial()] = outcome;
            }else{
                throw 'is not a qti outcome declaration';
            }
            return this;
        },
        addModalFeedback : function(feedback){
            if(Element.isA(feedback, 'modalFeedback')){
                feedback.setRelatedItem(this);
                this.modalFeedbacks[feedback.getSerial()] = feedback;
            }else{
                throw 'is not a qti modal feedback';
            }
            return this;
        },
        getComposingElements : function(){
            var elts = this._super(), _this = this;
            _.each(['responses', 'outcomes', 'modalFeedbacks', 'stylesheets'], function(elementCollection){
                for(var i in _this[elementCollection]){
                    var elt = _this[elementCollection][i];
                    elts[i] = elt;
                    elts = _.extend(elts, elt.getComposingElements());
                }
            });
            if(this.responseProcessing instanceof Element){
                elts[this.responseProcessing.getSerial()] = this.responseProcessing;
            }
            return elts;
        },
        find : function(serial){
        
            var _this = this,
                found = this._super(serial);
            
            if(!found){
                
                _.each(['responses', 'outcomes', 'modalFeedbacks', 'stylesheets'], function(elementCollection){

                    var elt = _this[elementCollection][serial];

                    if(elt){
                        found = {'parent' : this, 'element' : elt};
                        return false;//break the each loop
                    }

                    //search inside each elements:
                    _.each(_this[elementCollection], function(elt){
                        found = elt.find(serial);
                        if(found){
                            return false;//break the each loop
                        }
                    });

                    if(found){
                        return false;//break the each loop
                    }

                });
            }
            return found;
        },
        getResponses : function(){
            return _.clone(this.responses);
        },
        getRelatedItem : function(){
            return this;
        },
        setNamespaces : function(namespaces){
            this.namespaces = namespaces;
        },
        getNamespaces : function(){
            return _.clone(this.namespaces);
        },
        addStylesheet : function(stylesheet){
            if(Element.isA(stylesheet, 'stylesheet')){
                stylesheet.setRelatedItem(this);
                this.stylesheets[stylesheet.getSerial()] = stylesheet;
            }else{
                throw 'is not a qti stylesheet declaration';
            }
            return this;
        },
        setResponseProcessing : function(rp){
            if(Element.isA(rp, 'responseProcessing')){
                rp.setRelatedItem(this);
                this.responseProcessing = rp;
            }else{
                throw 'is not a response processing';
            }
            return this;
        },
        toArray : function(){
            var arr = this._super();
            arr.outcomes = {};
            for(var i in this.outcomes){
                arr.outcomes[i] = this.outcomes[i].toArray();
            }
            arr.responses = {};
            for(var i in this.responses){
                arr.responses[i] = this.responses[i].toArray();
            }
            arr.namespaces = this.namespaces;
            arr.stylesheets = this.stylesheets;
            return arr;
        }
    });

    Container.augment(Item);

    return Item;
});
define('taoQtiItem/qtiItem/core/Stylesheet',['taoQtiItem/qtiItem/core/Element', 'lodash', 'taoQtiItem/qtiItem/helper/rendererConfig'], function(Element, _, rendererConfig){
    
    var Stylesheet = Element.extend({
        qtiClass : 'stylesheet',
        render : function(){
            
            var args = rendererConfig.getOptionsFromArguments(arguments),
                renderer = args.renderer||this.getRenderer(),
                defaultData = {},
                baseUrl = renderer.getOption('baseUrl')||'',
                href = this.attr('href');
            
            if(!href.match(/^http/i)){
                defaultData.attributes = {href : baseUrl + href};
            }
            
            return this._super(_.merge(defaultData, args.data), args.placeholder, args.subclass, renderer);
        }
    });
    
    return Stylesheet;
});
define('taoQtiItem/qtiCreator/model/Stylesheet',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/Stylesheet'
], function(_, editable, Stylesheet){
    
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                href : 'css/tao-user-styles.css',
                title : '',
                type:'text/css',
                media:'all'
            };
        }
    });

    return Stylesheet.extend(methods);
});
define('taoQtiItem/qtiItem/core/ResponseProcessing',['taoQtiItem/qtiItem/core/Element', 'lodash'], function(Element, _){
    
    var ResponseProcessing = Element.extend({
        qtiClass : 'responseProcessing',
        processingType : '',
        xml : ''
    });
    
    return ResponseProcessing;
});
define('taoQtiItem/qtiCreator/model/ResponseProcessing',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/ResponseProcessing'
], function(_, editable, ResponseProcessing){

    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {};
        },
        setProcessingType : function(processingType){
        
            if(this.processingType !== processingType){
                
                if(this.processingType === 'custom'){

                    //change all response template to default : "correct"
                    _.each(this.getRelatedItem().getResponses(), function(r){
                         r.setTemplate('MATCH_CORRECT');
                    });
                }
                
                this.processingType = processingType;
            }

        }
    });

    return ResponseProcessing.extend(methods);
});
define('taoQtiItem/qtiItem/core/variables/VariableDeclaration',['taoQtiItem/qtiItem/core/IdentifiedElement'], function(IdentifiedElement){

    /**
     * It is the top abstract class for all variable classes
     * (so not renderable and qtiClass undefined)
     */
    var VariableDeclaration = IdentifiedElement.extend({
        init : function(serial, attributes){
            this._super(serial, attributes);
            this.defaultValue = null;
        },
        is : function(qtiClass){
            return (qtiClass === 'variableDeclaration') || this._super(qtiClass);
        },
        toArray : function(){
            var arr = this._super();
            arr.defaultValue = this.defaultValue;
            return arr;
        }
    });

    return VariableDeclaration;
});
define('taoQtiItem/qtiItem/core/variables/OutcomeDeclaration',['taoQtiItem/qtiItem/core/variables/VariableDeclaration'], function(VariableDeclaration){
    return  VariableDeclaration.extend({
        qtiClass : 'outcomeDeclaration'
    });
});
define('taoQtiItem/qtiCreator/model/variables/OutcomeDeclaration',['lodash', 'taoQtiItem/qtiCreator/model/mixin/editable', 'taoQtiItem/qtiItem/core/variables/OutcomeDeclaration'], function(_, editable, OutcomeDeclaration){
    var methods = {};
    _.extend(methods, editable);
    return OutcomeDeclaration.extend(methods);
});

define('taoQtiItem/qtiItem/core/feedbacks/ModalFeedback',['taoQtiItem/qtiItem/core/IdentifiedElement', 'taoQtiItem/qtiItem/mixin/Container'], function(IdentifiedElement, Container){
    
    var ModalFeedback = IdentifiedElement.extend({
        'qtiClass' : 'modalFeedback',
        is : function(qtiClass){
            return (qtiClass === 'feedback') || this._super(qtiClass);
        }
    });
    
    Container.augment(ModalFeedback);
    
    return ModalFeedback;
});
define('taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/feedbacks/ModalFeedback'
], function(_,editable,ModalFeedback){
    
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                title : 'modal feedback title',
                showHide : 'show'
            };
        }
    });
    
    return ModalFeedback.extend(methods);
});
define('taoQtiItem/qtiCreator/model/Item',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiCreator/model/mixin/editableContainer',
    'taoQtiItem/qtiItem/core/Item',
    'taoQtiItem/qtiCreator/model/Stylesheet',
    'taoQtiItem/qtiCreator/model/ResponseProcessing',
    'taoQtiItem/qtiCreator/model/variables/OutcomeDeclaration',
    'taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback'
], function(_, editable, editableContainer, Item, Stylesheet, ResponseProcessing, OutcomeDeclaration, ModalFeedback){
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, editableContainer);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                identifier : 'myItem_1',
                title : 'Item title',
                adaptive : false,
                timeDependent : false
            };
        },
        createResponseProcessing : function(){
            var rp = new ResponseProcessing();
            rp.processingType = 'templateDriven';
            this.setResponseProcessing(rp);
            return rp;
        },
        createStyleSheet : function(href){
            if(href && _.isString(href)){
                var stylesheet = new Stylesheet({href : href});
                stylesheet.setRenderer(this.getRenderer());
                this.addStylesheet(stylesheet);
                return stylesheet;
            }else{
                throw 'missing or invalid type for the required arg "href"';
                return null;
            }
        },
        createOutcomeDeclaration : function(attributes){

            var identifier = attributes.identifier || '';
            delete attributes.identifier;
            var outcome = new OutcomeDeclaration(attributes);

            this.addOutcomeDeclaration(outcome);
            outcome.buildIdentifier(identifier);

            return outcome;
        },
        createModalFeedback : function(attributes){

            var identifier = attributes.identifier || '';
            delete attributes.identifier;
            var modalFeedback = new ModalFeedback(attributes);

            this.addModalFeedback(modalFeedback);
            modalFeedback.buildIdentifier(identifier);
            modalFeedback.body('Some feedback text.');

            return modalFeedback;
        }
    });
    return Item.extend(methods);
});
define('taoQtiItem/qtiCreator/helper/itemLoader',[
    'jquery',
    'helpers',
    'taoQtiItem/qtiItem/core/Loader',
    'taoQtiItem/qtiCreator/model/Item',
    'taoQtiItem/qtiCreator/model/qtiClasses'
], function($, helpers, Loader, Item, qtiClasses){

    var _generateIdentifier = function(uri){
        var pos = uri.lastIndexOf('#');
        return uri.substr(pos + 1);
    };

    var creatorLoader = {
        loadItem : function(config, callback){

            if(config.uri){
                $.ajax({
                    url : helpers._url('getItemData', 'QtiCreator', 'taoQtiItem'),
                    dataType : 'json',
                    data : {
                        uri : config.uri
                    }
                }).done(function(data){

                    if(data.itemData && data.itemData.qtiClass === 'assessmentItem'){

                        var loader = new Loader().setClassesLocation(qtiClasses),
                            itemData = data.itemData;

                        loader.loadItemData(itemData, function(item){
                            callback(item, this.getLoadedClasses());
                        });
                    }else{

                        var item = new Item().id(_generateIdentifier(config.uri));
                        item.createOutcomeDeclaration({
                            identifier : 'SCORE',
                            cardinality : 'single',
                            baseType : 'float'
                        });
                        item.createResponseProcessing();
                        callback(item);
                    }

                });
            }
        }
    };

    return creatorLoader;
});

define('taoQtiItem/qtiCreator/renderers/config',['lodash', 'taoQtiItem/qtiCommonRenderer/renderers/config'], function(_, commonRenderConfig){
    
    var locations = _.defaults({
        '_container' : 'taoQtiItem/qtiCreator/renderers/Container',
        'assessmentItem' : 'taoQtiItem/qtiCreator/renderers/Item',
        'rubricBlock' : 'taoQtiItem/qtiCreator/renderers/RubricBlock',
        'img' : 'taoQtiItem/qtiCreator/renderers/Img',
        'math' : 'taoQtiItem/qtiCreator/renderers/Math',
        'modalFeedback' : 'taoQtiItem/qtiCreator/renderers/ModalFeedback',
        'choiceInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/ChoiceInteraction',
        'orderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/OrderInteraction',
        'matchInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/MatchInteraction',
        'associateInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/AssociateInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/InlineChoiceInteraction',
        'textEntryInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/TextEntryInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/HotspotInteraction',
        'selectPointInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/SelectPointInteraction',
        'graphicOrderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicOrderInteraction',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicAssociateInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicGapMatchInteraction',
        'mediaInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/MediaInteraction',
        'uploadInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/UploadInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/SliderInteraction',
        'simpleChoice.choiceInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleChoice.ChoiceInteraction',
        'simpleChoice.orderInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleChoice.OrderInteraction',
        'simpleAssociableChoice.associateInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleAssociableChoice.AssociateInteraction',
        'simpleAssociableChoice.matchInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleAssociableChoice.MatchInteraction'
    }, commonRenderConfig.locations);

    return {
        name: 'creatorRenderer',
        locations : locations
    };
});

define('taoQtiItem/qtiCreator/renderers/Renderer',['taoQtiItem/qtiRunner/core/Renderer', 'taoQtiItem/qtiCreator/renderers/config'], function(Renderer, config){
    return Renderer.build(config.locations, config.name);
});
define('taoQtiItem/qtiCreator/helper/creatorRenderer',['taoQtiItem/qtiCreator/renderers/Renderer', 'helpers', 'jquery'], function(Renderer, helpers, $){

    //configure and instanciate once only:
    var _creatorRenderer = null;

    var _singleton = function(){
        
        if(!_creatorRenderer 
            || !_creatorRenderer.getOption('interactionOptionForm') 
            || !$.contains(document, _creatorRenderer.getOption('interactionOptionForm')[0])){
            
            _creatorRenderer = new Renderer({
                baseUrl : '',
                lang : '',
                uri : '',
                shuffleChoices : false,
                itemOptionForm : $('#item-editor-item-property-bar .panel'),
                interactionOptionForm : $('#item-editor-interaction-property-bar .panel'),
                choiceOptionForm : $('#item-editor-choice-property-bar .panel'),
                responseOptionForm : $('#item-editor-response-property-bar .panel'),
                bodyElementOptionForm : $('#item-editor-body-element-property-bar .panel'),
                textOptionForm : $('#item-editor-text-property-bar .panel'),
                mediaManager : {
                    appendContainer : '#mediaManager',
                    browseUrl : helpers._url('files', 'ItemContent', 'taoItems'),
                    uploadUrl : helpers._url('upload', 'ItemContent', 'taoItems'),
                    deleteUrl : helpers._url('delete', 'ItemContent', 'taoItems'),
                    downloadUrl : helpers._url('download', 'ItemContent', 'taoItems'),
                }
            });
            
        }
        
        return _creatorRenderer;
    };


    return {
        get : function(){
            return _singleton();
        },
        setOption : function(name, value){
            _singleton().setOption(name, value);
        },
        setOptions : function(options){
            _singleton().setOptions(options);
        }
    };

});

define("json!taoQtiItem/qtiCreator/editor/resources/font-stacks.json", function(){ return {"sans-serif":["Arial, \"Helvetica Neue\", Helvetica, sans-serif","\"Avant Garde\", Avantgarde, \"Century Gothic\", CenturyGothic, \"AppleGothic\", sans-serif","Calibri, Candara, Segoe, \"Segoe UI\", Optima, Arial, sans-serif","Candara, Calibri, Segoe, \"Segoe UI\", Optima, Arial, sans-serif","\"Century Gothic\", CenturyGothic, AppleGothic, sans-serif","Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif","\"Franklin Gothic Medium\", \"Franklin Gothic\", \"ITC Franklin Gothic\", Arial, sans-serif","Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif","Futura, \"Century Gothic\", AppleGothic, \"Trebuchet MS\", sans-serif","Geneva, Verdana, \"Lucida Sans\", \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif","\"Gill Sans\", \"Gill Sans MT\", Calibri, sans-serif","\"Helvetica Neue\", Helvetica, Arial, sans-serif","Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif","\"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", Geneva, Verdana, sans-serif","Optima, Segoe, \"Segoe UI\", Candara, Calibri, Arial, sans-serif","\"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif","Tahoma, Verdana, Segoe, sans-serif","\"Trebuchet MS\", \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", Tahoma, sans-serif","Verdana, Geneva, Tahoma, sans-serif"],"serif":["Baskerville, \"Baskerville Old Face\", \"Hoefler Text\", Garamond, \"Times New Roman\", serif","\"Big Caslon\", \"Book Antiqua\", \"Palatino Linotype\", Georgia, serif","\"Bodoni MT\", Didot, \"Didot LT STD\", \"Hoefler Text\", Garamond, \"Times New Roman\", serif","\"Book Antiqua\", Palatino, \"Palatino Linotype\", \"Palatino LT STD\", Georgia, serif","\"Calisto MT\", \"Bookman Old Style\", Bookman, \"Goudy Old Style\", Garamond, \"Hoefler Text\", \"Bitstream Charter\", Georgia, serif","Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif","Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif\", \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif","Didot, \"Didot LT STD\", \"Hoefler Text\", Garamond, \"Times New Roman\", serif","Garamond, Baskerville, \"Baskerville Old Face\", \"Hoefler Text\", \"Times New Roman\", serif","Georgia, Palatino,\" Palatino Linotype\", Times, \"Times New Roman\", serif","\"Goudy Old Style\", Garamond, \"Big Caslon\", \"Times New Roman\", serif","\"Hoefler Text\", \"Baskerville old face\", Garamond, \"Times New Roman\", serif","\"Lucida Bright\", Georgia, serif","\"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif","Perpetua, Baskerville, \"Big Caslon\", \"Palatino Linotype\", Palatino, \"URW Palladio L\", \"Nimbus Roman No9 L\", serif","Rockwell, \"Courier Bold\", Courier, Georgia, Times, \"Times New Roman\", serif","\"Times New Roman\", TimesNewRoman, Times, Baskerville, Georgia, serif"],"monospace":["\"Andale Mono\", AndaleMono, monospace","Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace","\"Courier New\", Courier, \"Lucida Sans Typewriter\", \"Lucida Typewriter\", monospace","\"Lucida Console\", \"Lucida Sans Typewriter\", Monaco, \"Bitstream Vera Sans Mono\", monospace","Monaco, Consolas, \"Lucida Console\", monospace","\"Rockwell Extra Bold\", \"Rockwell Bold\", monospace"]};});


define('tpl!taoQtiItem/qtiCreator/tpl/toolbars/cssToggler', ['handlebars'], function(Handlebars){ 
return Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n<li data-css-res=\"";
  if (helper = helpers.path) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.path); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <span class=\"icon-preview style-sheet-toggler\" title=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></span>\n    <span class=\"file-label truncate\" title=\"";
  if (helper = helpers.editLabelTxt) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.editLabelTxt); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    <input type=\"text\" class=\"style-sheet-label-editor\" value=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <span class=\"icon-bin\" title=\"";
  if (helper = helpers.deleteTxt) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.deleteTxt); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-role=\"css-delete\"></span>\n    <span class=\"icon-download\" title=\"";
  if (helper = helpers.downloadTxt) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.downloadTxt); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-role=\"css-download\"></span>\n</li>\n";
  return buffer;
  }

  stack1 = helpers.each.call(depth0, (depth0 && depth0.stylesheets), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });
});

/*
* jQuery File Download Plugin v1.3.3
*
* http://www.johnculviner.com
*
* Copyright (c) 2012 - John Culviner
*
* Licensed under the MIT license:
*   http://www.opensource.org/licenses/mit-license.php
*/

(function($){

$.extend({
    //
    //$.fileDownload('/path/to/url/', options)
    //  see directly below for possible 'options'
    fileDownload: function (fileUrl, options) {

        var defaultFailCallback = function (responseHtml, url) {
            alert("A file download error has occurred, please try again.");
        };

        //provide some reasonable defaults to any unspecified options below
        var settings = $.extend({

            //
            //Requires jQuery UI: provide a message to display to the user when the file download is being prepared before the browser's dialog appears
            //
            preparingMessageHtml: null,

            //
            //Requires jQuery UI: provide a message to display to the user when a file download fails
            //
            failMessageHtml: null,

            //
            //the stock android browser straight up doesn't support file downloads initiated by a non GET: http://code.google.com/p/android/issues/detail?id=1780
            //specify a message here to display if a user tries with an android browser
            //if jQuery UI is installed this will be a dialog, otherwise it will be an alert
            //
            androidPostUnsupportedMessageHtml: "Unfortunately your Android browser doesn't support this type of file download. Please try again with a different browser.",

            //
            //Requires jQuery UI: options to pass into jQuery UI Dialog
            //
            dialogOptions: { modal: true },

            //
            //a function to call after a file download dialog/ribbon has appeared
            //Args:
            //  url - the original url attempted
            //
            successCallback: function (url) { },

            //
            //a function to call after a file download dialog/ribbon has appeared
            //Args:
            //  responseHtml    - the html that came back in response to the file download. this won't necessarily come back depending on the browser.
            //                      in less than IE9 a cross domain error occurs because 500+ errors cause a cross domain issue due to IE subbing out the
            //                      server's error message with a "helpful" IE built in message
            //  url             - the original url attempted
            //
            failCallback: defaultFailCallback,

            //
            // the HTTP method to use. Defaults to "GET".
            //
            httpMethod: "GET",

            //
            // if specified will perform a "httpMethod" request to the specified 'fileUrl' using the specified data.
            // data must be an object (which will be $.param serialized) or already a key=value param string
            //
            data: null,

            //
            //a period in milliseconds to poll to determine if a successful file download has occured or not
            //
            checkInterval: 100,

            //
            //the cookie name to indicate if a file download has occured
            //
            cookieName: "fileDownload",

            //
            //the cookie value for the above name to indicate that a file download has occured
            //
            cookieValue: "true",

            //
            //the cookie path for above name value pair
            //
            cookiePath: "/",

            //
            //the title for the popup second window as a download is processing in the case of a mobile browser
            //
            popupWindowTitle: "Initiating file download...",

            //
            //Functionality to encode HTML entities for a POST, need this if data is an object with properties whose values contains strings with quotation marks.
            //HTML entity encoding is done by replacing all &,<,>,',",\r,\n characters.
            //Note that some browsers will POST the string htmlentity-encoded whilst others will decode it before POSTing.
            //It is recommended that on the server, htmlentity decoding is done irrespective.
            //
            encodeHTMLEntities: true
        }, options);


        //Setup mobile browser detection: Partial credit: http://detectmobilebrowser.com/
        var userAgent = (navigator.userAgent || navigator.vendor || window.opera).toLowerCase();

        var isIos = false;                  //has full support of features in iOS 4.0+, uses a new window to accomplish this.
        var isAndroid = false;              //has full support of GET features in 4.0+ by using a new window. Non-GET is completely unsupported by the browser. See above for specifying a message.
        var isOtherMobileBrowser = false;   //there is no way to reliably guess here so all other mobile devices will GET and POST to the current window.

        if (/ip(ad|hone|od)/.test(userAgent)) {

            isIos = true;

        } else if (userAgent.indexOf('android') != -1) {

            isAndroid = true;

        } else {

            isOtherMobileBrowser = /avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|playbook|silk|iemobile|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4));

        }

        var httpMethodUpper = settings.httpMethod.toUpperCase();

        if (isAndroid && httpMethodUpper != "GET") {
            //the stock android browser straight up doesn't support file downloads initiated by non GET requests: http://code.google.com/p/android/issues/detail?id=1780

            if ($().dialog) {
                $("<div>").html(settings.androidPostUnsupportedMessageHtml).dialog(settings.dialogOptions);
            } else {
                alert(settings.androidPostUnsupportedMessageHtml);
            }

            return;
        }

        //wire up a jquery dialog to display the preparing message if specified
        var $preparingDialog = null;
        if (settings.preparingMessageHtml) {

            $preparingDialog = $("<div>").html(settings.preparingMessageHtml).dialog(settings.dialogOptions);

        }

        var internalCallbacks = {

            onSuccess: function (url) {

                //remove the perparing message if it was specified
                if ($preparingDialog) {
                    $preparingDialog.dialog('close');
                };

                settings.successCallback(url);

            },

            onFail: function (responseHtml, url) {

                //remove the perparing message if it was specified
                if ($preparingDialog) {
                    $preparingDialog.dialog('close');
                };

                //wire up a jquery dialog to display the fail message if specified
                if (settings.failMessageHtml) {

                    $("<div>").html(settings.failMessageHtml).dialog(settings.dialogOptions);

                    //only run the fallcallback if the developer specified something different than default
                    //otherwise we would see two messages about how the file download failed
                    if (settings.failCallback != defaultFailCallback) {
                        settings.failCallback(responseHtml, url);
                    }

                } else {

                    settings.failCallback(responseHtml, url);
                }
            }
        };


        //make settings.data a param string if it exists and isn't already
        if (settings.data !== null && typeof settings.data !== "string") {
            settings.data = $.param(settings.data);
        }


        var $iframe,
            downloadWindow,
            formDoc,
            $form;

        if (httpMethodUpper === "GET") {

            if (settings.data !== null) {
                //need to merge any fileUrl params with the data object

                var qsStart = fileUrl.indexOf('?');

                if (qsStart != -1) {
                    //we have a querystring in the url

                    if (fileUrl.substring(fileUrl.length - 1) !== "&") {
                        fileUrl = fileUrl + "&";
                    }
                } else {

                    fileUrl = fileUrl + "?";
                }

                fileUrl = fileUrl + settings.data;
            }

            if (isIos || isAndroid) {

                downloadWindow = window.open(fileUrl);
                downloadWindow.document.title = settings.popupWindowTitle;
                window.focus();

            } else if (isOtherMobileBrowser) {

                window.location(fileUrl);

            } else {

                //create a temporary iframe that is used to request the fileUrl as a GET request
                $iframe = $("<iframe>")
                    .hide()
                    .attr("src", fileUrl)
                    .appendTo("body");
            }

        } else {

            var formInnerHtml = "";

            if (settings.data !== null) {

                $.each(settings.data.replace(/\+/g, ' ').split("&"), function () {

                    var kvp = this.split("=");

                    var key = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[0])) : decodeURIComponent(kvp[0]);
                    if (!key) return;
                    var value = kvp[1] || '';
                    value = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[1])) : decodeURIComponent(kvp[1]);

                    formInnerHtml += '<input type="hidden" name="' + key + '" value="' + value + '" />';
                });
            }

            if (isOtherMobileBrowser) {

                $form = $("<form>").appendTo("body");
                $form.hide()
                    .attr('method', settings.httpMethod)
                    .attr('action', fileUrl)
                    .html(formInnerHtml);

            } else {

                if (isIos) {

                    downloadWindow = window.open("about:blank");
                    downloadWindow.document.title = settings.popupWindowTitle;
                    formDoc = downloadWindow.document;
                    window.focus();

                } else {

                    $iframe = $("<iframe style='display: none' src='about:blank'></iframe>").appendTo("body");
                    formDoc = getiframeDocument($iframe);
                }

                formDoc.write("<html><head></head><body><form method='" + settings.httpMethod + "' action='" + fileUrl + "'>" + formInnerHtml + "</form>" + settings.popupWindowTitle + "</body></html>");
                $form = $(formDoc).find('form');
            }

            $form.submit();
        }


        //check if the file download has completed every checkInterval ms
        setTimeout(checkFileDownloadComplete, settings.checkInterval);


        function checkFileDownloadComplete() {

            //has the cookie been written due to a file download occuring?
            if (document.cookie.indexOf(settings.cookieName + "=" + settings.cookieValue) != -1) {

                //execute specified callback
                internalCallbacks.onSuccess(fileUrl);

                //remove the cookie and iframe
                var date = new Date(1000);
                document.cookie = settings.cookieName + "=; expires=" + date.toUTCString() + "; path=" + settings.cookiePath;

                cleanUp(false);

                return;
            }

            //has an error occured?
            //if neither containers exist below then the file download is occuring on the current window
            if (downloadWindow || $iframe) {

                //has an error occured?
                try {

                    var formDoc;
                    if (downloadWindow) {
                        formDoc = downloadWindow.document;
                    } else {
                        formDoc = getiframeDocument($iframe);
                    }

                    if (formDoc && formDoc.body != null && formDoc.body.innerHTML.length > 0) {

                        var isFailure = true;

                        if ($form && $form.length > 0) {
                            var $contents = $(formDoc.body).contents().first();

                            if ($contents.length > 0 && $contents[0] === $form[0]) {
                                isFailure = false;
                            }
                        }

                        if (isFailure) {
                            internalCallbacks.onFail(formDoc.body.innerHTML, fileUrl);

                            cleanUp(true);

                            return;
                        }
                    }
                }
                catch (err) {

                    //500 error less than IE9
                    internalCallbacks.onFail('', fileUrl);

                    cleanUp(true);

                    return;
                }
            }


            //keep checking...
            setTimeout(checkFileDownloadComplete, settings.checkInterval);
        }

        //gets an iframes document in a cross browser compatible manner
        function getiframeDocument($iframe) {
            var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;
            if (iframeDoc.document) {
                iframeDoc = iframeDoc.document;
            }
            return iframeDoc;
        }

        function cleanUp(isFailure) {

            setTimeout(function() {

                if (downloadWindow) {

                    if (isAndroid) {
                        downloadWindow.close();
                    }

                    if (isIos) {
                        if (isFailure) {
                            downloadWindow.focus(); //ios safari bug doesn't allow a window to be closed unless it is focused
                            downloadWindow.close();
                        } else {
                            downloadWindow.focus();
                        }
                    }
                }

            }, 0);
        }

        function htmlSpecialCharsEntityEncode(str) {
            return str.replace(/&/gm, '&amp;')
                .replace(/\n/gm, "&#10;")
                .replace(/\r/gm, "&#13;")
                .replace(/</gm, '&lt;')
                .replace(/>/gm, '&gt;')
                .replace(/"/gm, '&quot;')
                .replace(/'/gm, '&apos;'); //single quotes just to be safe
        }
    }
});

})(jQuery);
define("lib/jquery.fileDownload", function(){});

define('taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',[
    'jquery',
    'lodash',
    'helpers',
    'i18n',
    'tpl!taoQtiItem/qtiCreator/tpl/toolbars/cssToggler',
    'lib/jquery.fileDownload'
], function (
    $,
    _,
    helpers,
    __,
    cssTpl
    ) {
   // 'use strict'

    var itemConfig;

    /**
     * generate Ajax URI
     * @param action
     * @returns {*}
     */
    var _getUri = function(action) {
        return helpers._url(action, 'QtiCssAuthoring', 'taoQtiItem');
    };

    /**
     * Extract the file name from a path
     * @param path
     * @returns {*}
     * @private
     */
    var _basename = function(path) {
        return path.substring(path.lastIndexOf('/') + 1);
    };

    /**
     * Manage style rules as CSS rather than style attributes.
     * Must be used by all widgets that change the style of an item.
     */
    var styleEditor = (function ($, doc) {

        // stylesheet as object
        var style = {},
            // DOM element to hold the style
            $styleElem = (function () {
                var styleElem = $('<style>', { id : 'item-editor-user-styles' } );
                $('head').append(styleElem);
                return styleElem;
            }()),
            currentItem,
            common = {
                title: __('Disable this stylesheet temporarily'),
                deleteTxt: __('Delete this stylesheet'),
                editLabelTxt: __('Edit stylesheet label'),
                downloadTxt: __('Download this stylesheet'),
                preparingMessageHtml: __('Preparing CSS, please wait…'),
                failMessageHtml: __('There was a problem downloading your CSS, please try again.'),
                listing: $('#style-sheet-toggler')
            },
            customStylesheet = '';

        /**
         * Create CSS and add it to DOM
         *
         */
        var create = function() {

            var key1, // first level key, could be selector or media query
                key2, // second level key, could be css property or selector
                mSelector, // selector inside a media query
                mProp, // property inside a media query
                css = '';

            if(_.isEmpty(style)){
                return erase();
            }

            // rebuild CSS
            for (key1 in style) {
                if (!style.hasOwnProperty(key1)) {
                    continue;
                }

                css += key1 + '{';
                for (key2 in style[key1]) {
                    if (!style[key1].hasOwnProperty(key2)) {
                        continue;
                    }
                    // in the case of a surrounding media query
                    if (_.isPlainObject(style[key1][key2])) {
                        for (mSelector in style[key1][key2]) {
                            css += key2 + '{';
                            for (mProp in style[key1][key2]) {
                                css += mProp + ':' + style[key1][key2][mSelector] + ';'
                            }
                            css += '}';
                        }
                    }
                    // regular selectors
                    else {
                        css += key2 + ':' + style[key1][key2] + ';'
                    }
                }
                css += '}\n';
            }

            $styleElem.text(css);
        };

        /**
         * Apply rule to CSS
         *
         * @param {{string}} selector
         * @param {{string}} property
         * @param {{string}} value
         */
        var apply = function (selector, property, value) {
            style[selector] = style[selector] || {};

            // delete this rule
            if (!value) {
                delete(style[selector][property]);
                if(_.size(style[selector]) === 0) {
                    delete(style[selector]);
                }
            }
            // add this rule
            else {
                style[selector][property] = value;
            }

            // apply rule
            create();

        };


        /**
         * Delete all custom styles
         */
        var erase = function() {
            style = {};
            $styleElem.text('');
            return false;
        };

        /**
         * Save the resulting CSS to a file
         */
        var save = function () {
            verifyInit();
            return $.post(_getUri('save'), _.extend({}, itemConfig,
                {
                    cssJson: JSON.stringify(style),
                    stylesheetUri: customStylesheet.attr('href')
                }
            ));
        };


        /**
         * Download CSS as file
         */
        var download = function(uri) {
            verifyInit();
            $.fileDownload(_getUri('download'), {
                preparingMessageHtml: common.preparingMessageHtml,
                failMessageHtml: common.failMessageHtml,
                successCallback: function () { },
                httpMethod: 'POST',
                data: _.extend({}, itemConfig, { stylesheetUri: uri })
            });
        };


        /**
         * Has the class been initialized
         *
         * @returns {boolean}
         */
        var verifyInit = function() {
            if(!itemConfig) {
                throw new Error('Missing itemConfig, did you call styleEditor.init()?')
            }
            return true;
        };

        /**
         * Add a single stylesheet, the custom stylesheet will be loaded as object
         *
         * @param stylesheet
         * @returns {*} promise
         */
        var addStylesheet = function(stylesheet) {

            var fileName,
                link,
                stylesheets = [],
                listEntry;

            // argument is uri
            if(_.isString(stylesheet)) {
                stylesheet = currentItem.createStyleSheet(stylesheet);
            }

            fileName = _basename(stylesheet.attr('href'));
            link = $(stylesheet.render());

            // add other stylesheets to head
            $styleElem.before(link);

            stylesheets.push({
                path: stylesheet.attr('href'),
                label: (stylesheet.attr('title') || fileName),
                title: common.title,
                deleteTxt: common.deleteTxt,
                downloadTxt: common.downloadTxt,
                editLabelTxt: common.editLabelTxt
            });

            // create list entry
            listEntry = $(cssTpl({ stylesheets: stylesheets }));

            listEntry.data('stylesheetObj', stylesheet);

            // initialize download button
            common.listing.append(listEntry);
        };


        /**
         * Add style sheets to toggler
         * @param item
         */
        var addItemStylesheets = function() {
            
            var currentStylesheet;

            for(var key in currentItem.stylesheets) {
                if(!currentItem.stylesheets.hasOwnProperty(key)) {
                    continue;
                }

                currentStylesheet = currentItem.stylesheets[key];

                if('tao-user-styles.css' === _basename(currentStylesheet.attr('href'))) {
                    customStylesheet = currentStylesheet;
                    continue;
                }

                // add those that are loaded synchronously
                addStylesheet(currentItem.stylesheets[key]);
            }
            
            // if no custom css had been found, add empty stylesheet anyway
            if(!customStylesheet) {
                customStylesheet = currentItem.createStyleSheet('style/custom/tao-user-styles.css');
            }
        };
        
        /**
         * retrieve the current item
         *
         * @returns {*}
         */
        var getItem = function() {
            return currentItem;
        };


        /**
         * Initialize class
         * @param config
         */
        var init = function(item, config) {
            
            // promise
            currentItem = item;
            
            //prepare config object (don't pass all of them, otherwise, $.param will break)
            itemConfig = {
                uri : config.uri,
                lang : config.lang,
                baseUrl : config.baseUrl
            };
            
            // this creates at the same time customStylesheet in case it doesn't exist yet
            addItemStylesheets();

            var stylesheetUri = _getUri('load') + '?',
                resizerTarget = $('#item-editor-item-resizer').data('target'),
                href = customStylesheet.attr('href');
            
            currentItem.data('responsive', true);
            
            stylesheetUri += $.param(_.extend({}, itemConfig, { stylesheetUri: href }));
            require(['json!' + stylesheetUri], function(_style) {

                // copy style to global style
                style = _style;

                // apply rules
                create();

                // reset meta in case the width is set in the custom stylesheet
                currentItem.data('responsive', style[resizerTarget] && style[resizerTarget].width);

                // inform editors about custom sheet
                $(doc).trigger('customcssloaded.styleeditor', style);
            });

        };

        var getStyle = function() {
            return style;
        };

        // expose public functions
        return {
            apply: apply,
            save: save,
            download: download,
            erase: erase,
            init: init,
            create: create,
            getItem: getItem,
            getStyle: getStyle,
            addStylesheet: addStylesheet
        }
    }($, document));

    return styleEditor;
});
define('taoQtiItem/qtiCreator/editor/styleEditor/fontSelector',[
    'jquery',
    'json!taoQtiItem/qtiCreator/editor/resources/font-stacks.json',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',
    'i18n',
    'select2'
], function ($, fontStacks, styleEditor, __) {
    'use strict'

    /**
     * Populate a select box with a list of fonts to select from.
     * On change apply the selected font to the specified target.
     *
     * @example
     * The expected mark-up must be like this:
     * <select
     *   data-target="selector-of-targeted-element"
     *   data-not-selected="Select a font
     *   data-selected="Reset to default">
     * <option value=""></option>
     *
     * The function is called like this:
     * fontSelector('the-select-box-selector');
     *
     * @param selector
     */
    var fontSelector = function () {
        var fontSelector = $('select#item-editor-font-selector'),
            target = fontSelector.data('target'),
            $target = $(target),
            normalize = function (font) {
                return font.replace(/"/g, "'").replace(/, /g, ",");
            },
            clean = function (font) {
                return font.substring(0, font.indexOf(',')).replace(/'/g, '');
            },
            resetButton =  fontSelector.parent().find('[data-role="font-selector-reset"]'),
            generic,
            optGroup,
            option,
            i = 0,
            l,
            toLabel = function (font) {
                font = font.replace(/-/g, ' ');
                return (font + '').replace(/^([a-z\u00E0-\u00FC])|\s+([a-z\u00E0-\u00FC])/g, function ($1) {
                    return $1.toUpperCase();
                });
            },
            format = function (state) {
                var originalOption = state.element;
                if (!state.id) return state.text;
                return '<span style="font-size: 12px;' + $(originalOption).attr('style') + '">' + state.text + '</span>';
            },
            reset = function() {
                styleEditor.apply(target, 'font-family');
                fontSelector.select2('val', $target.css('font-family'));
            };


        fontSelector.append('<option value="">' + __('Default')  + '</option>');

        for (generic in fontStacks) {
            if (fontStacks.hasOwnProperty(generic)) {
                optGroup = $('<optgroup>', { label: toLabel(generic) });
                l = fontStacks[generic].length;
                for (i = 0; i < l; i++) {
                    // normalize quotes
                    fontStacks[generic][i] = normalize(fontStacks[generic][i]);
                    option = $('<option>', {
                        value: fontStacks[generic][i],
                        text: clean(fontStacks[generic][i])
                    })
                        .css({
                            fontFamily: fontStacks[generic][i]
                        });
                    optGroup.append(option);
                }
                fontSelector.append(optGroup);
            }
        }



        resetButton.on('click', reset);

        fontSelector.select2({
            formatResult: format,
            formatSelection: format,
            width: 'resolve'
        });

        $(document).on('customcssloaded.styleeditor', function(e, style) {
            //@todo : to be fixed ! currently disabled because keep triggering error "style is undefined"
            return;
            if(style[target] && style[target]['font-family']) {
                fontSelector.select2('val', style[target]['font-family']);
            }
        });

        fontSelector.on('change', function () {
            styleEditor.apply(target, 'font-family', $(this).val());
        });
    };

    return fontSelector;
});


/**
 * Farbtastic Color Picker 1.2
 * © 2008 Steven Wittens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/**
 * NOTE: THIS IS A MOD OF COLOR PICKER 1.2 - DO NOT UPGRADE!
 * 2014-03-06  dieter@taotesting.com
 */

jQuery.fn.farbtastic = function(callback) {
    $.farbtastic(this, callback);
    return this;
};

jQuery.farbtastic = function(container, callback) {
    if (!container.length) return;
    var container = $(container).get(0);
    return container.farbtastic || (container.farbtastic = new jQuery._farbtastic(container, callback));
}

jQuery._farbtastic = function(container, callback) {
    // Store farbtastic object
    var fb = this;

    // Insert markup
    var e = $('<div>', {
        'class': 'farbtastic'
    }),
        colorObj = $('<div>', {
            'class': 'color'
        }),
        wheelObj = $('<div>', {
            'class': 'wheel'
        }),
        overlayObj = $('<div>', {
            'class': 'overlay'
        }),
        hMarkerObj = $('<div>', {
            'class': 'h-marker marker'
        }),
        slMarkerObj = $('<div>', {
            'class': 'sl-marker marker'
        });

    container = $(container);

    $(e).append(colorObj);
    $(e).append(wheelObj);
    $(e).append(overlayObj);
    $(e).append(hMarkerObj);
    $(e).append(slMarkerObj);

    container.append(e);


    fb.wheel = wheelObj.get(0);
    // Dimensions
    fb.radius = 70;
    fb.square = overlayObj.width();
    fb.width = e.width();


    /**
     * Link to the given element(s) or callback.
     */
    fb.linkTo = function(callback) {
        // Unbind previous nodes
        if (typeof fb.callback == 'object') {
            $(fb.callback).unbind('keyup', fb.updateValue);
        }

        // Reset color
        fb.color = null;

        // Bind callback or elements
        if (typeof callback == 'function') {
            fb.callback = callback;
        } else if (typeof callback == 'object' || typeof callback == 'string') {
            fb.callback = $(callback);
            fb.callback.bind('keyup', fb.updateValue);
            if (fb.callback.get(0).value) {
                fb.setColor(fb.callback.get(0).value);
            }
        }
        return this;
    };

    fb.updateValue = function(event) {
        if (this.value && this.value != fb.color) {
            fb.setColor(this.value);
        }
    };

    /**
     * Change color with HTML syntax #123456
     */
    fb.setColor = function(color) {
        var unpack = fb.unpack(color);
        if (fb.color != color && unpack) {
            fb.color = color;
            fb.rgb = unpack;
            fb.hsl = fb.RGBToHSL(fb.rgb);
            fb.updateDisplay();
        }
        return this;
    };


    /**
     * Change color with HSL triplet [0..1, 0..1, 0..1]
     */
    fb.setHSL = function(hsl) {
        fb.hsl = hsl;
        fb.rgb = fb.HSLToRGB(hsl);
        fb.color = fb.pack(fb.rgb);
        fb.updateDisplay();
        return this;
    }

    /////////////////////////////////////////////////////

    /**
     * Retrieve the coordinates of the given event relative to the center
     * of the widget.
     */
    fb.widgetCoords = function(event) {
        var x, y;
        var el = event.target || event.srcElement;
        var reference = fb.wheel;

        if (typeof event.offsetX != 'undefined') {
            // Use offset coordinates and find common offsetParent
            var pos = {
                x: event.offsetX,
                y: event.offsetY
            };

            // Send the coordinates upwards through the offsetParent chain.
            var e = el;
            while (e) {
                e.mouseX = pos.x;
                e.mouseY = pos.y;
                pos.x += e.offsetLeft;
                pos.y += e.offsetTop;
                e = e.offsetParent;
            }

            // Look for the coordinates starting from the wheel widget.
            var e = reference;
            var offset = {
                x: 0,
                y: 0
            }
            while (e) {
                if (typeof e.mouseX != 'undefined') {
                    x = e.mouseX - offset.x;
                    y = e.mouseY - offset.y;
                    break;
                }
                offset.x += e.offsetLeft;
                offset.y += e.offsetTop;
                e = e.offsetParent;
            }

            // Reset stored coordinates
            e = el;
            while (e) {
                e.mouseX = undefined;
                e.mouseY = undefined;
                e = e.offsetParent;
            }
        } else {
            // Use absolute coordinates
            var pos = fb.absolutePosition(reference);
            x = (event.pageX || 0 * (event.clientX + $('html').get(0).scrollLeft)) - pos.x;
            y = (event.pageY || 0 * (event.clientY + $('html').get(0).scrollTop)) - pos.y;
        }
        // Subtract distance to middle
        return {
            x: x - fb.width / 2,
            y: y - fb.width / 2
        };
    }

    /**
     * Mousedown handler
     */
    fb.mousedown = function(event) {
        // Capture mouse
        if (!document.dragging) {
            $(document).bind('mousemove', fb.mousemove).bind('mouseup', fb.mouseup);
            document.dragging = true;
        }

        // Check which area is being dragged
        var pos = fb.widgetCoords(event);
        fb.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) * 2 > fb.square;

        // Process
        fb.mousemove(event);
        return false;
    }

    /**
     * Mousemove handler
     */
    fb.mousemove = function(event) {
        // Get coordinates relative to color picker center
        var pos = fb.widgetCoords(event);

        // Set new HSL parameters
        if (fb.circleDrag) {
            var hue = Math.atan2(pos.x, -pos.y) / 6.28;
            if (hue < 0) hue += 1;
            fb.setHSL([hue, fb.hsl[1], fb.hsl[2]]);
        } else {
            var sat = Math.max(0, Math.min(1, -(pos.x / fb.square) + .5));
            var lum = Math.max(0, Math.min(1, -(pos.y / fb.square) + .5));
            fb.setHSL([fb.hsl[0], sat, lum]);
        }
        return false;
    }

    /**
     * Mouseup handler
     */
    fb.mouseup = function() {
        // Uncapture mouse
        $(document).unbind('mousemove', fb.mousemove);
        $(document).unbind('mouseup', fb.mouseup);
        document.dragging = false;
    }

    /**
     * Update the markers and styles
     */
    fb.updateDisplay = function() {
        // Markers
        var angle = fb.hsl[0] * 6.28;
        $('.h-marker', e).css({
            left: Math.round(Math.sin(angle) * fb.radius + fb.width / 2) + 'px',
            top: Math.round(-Math.cos(angle) * fb.radius + fb.width / 2) + 'px'
        });

        $('.sl-marker', e).css({
            left: Math.round(fb.square * (.5 - fb.hsl[1]) + fb.width / 2) + 'px',
            top: Math.round(fb.square * (.5 - fb.hsl[2]) + fb.width / 2) + 'px'
        });

        // Saturation/Luminance gradient
        $('.color', e).css('backgroundColor', fb.pack(fb.HSLToRGB([fb.hsl[0], 1, 0.5])));

        // Linked elements or callback
        if (typeof fb.callback == 'object') {
            // Set background/foreground color
            $(fb.callback).css({
                backgroundColor: fb.color,
                color: fb.hsl[2] > 0.5 ? '#000' : '#fff'
            });

            // Change linked value
            $(fb.callback).each(function() {
                if (this.value && this.value != fb.color) {
                    this.value = fb.color;
                }
            });
        } else if (typeof fb.callback == 'function') {
            fb.callback.call(fb, fb.color);
        }
        // mod by dieter
        container.trigger('colorchange.farbtastic', [fb.color]);
    }

    /**
     * Get absolute position of element
     */
    fb.absolutePosition = function(el) {
        var r = {
            x: el.offsetLeft,
            y: el.offsetTop
        };
        // Resolve relative to offsetParent
        if (el.offsetParent) {
            var tmp = fb.absolutePosition(el.offsetParent);
            r.x += tmp.x;
            r.y += tmp.y;
        }
        return r;
    };

    /* Various color utility functions */
    fb.pack = function(rgb) {
        var r = Math.round(rgb[0] * 255);
        var g = Math.round(rgb[1] * 255);
        var b = Math.round(rgb[2] * 255);
        return '#' + (r < 16 ? '0' : '') + r.toString(16) +
            (g < 16 ? '0' : '') + g.toString(16) +
            (b < 16 ? '0' : '') + b.toString(16);
    }

    fb.unpack = function(color) {
        if (color.length == 7) {
            return [parseInt('0x' + color.substring(1, 3)) / 255,
                parseInt('0x' + color.substring(3, 5)) / 255,
                parseInt('0x' + color.substring(5, 7)) / 255];
        } else if (color.length == 4) {
            return [parseInt('0x' + color.substring(1, 2)) / 15,
                parseInt('0x' + color.substring(2, 3)) / 15,
                parseInt('0x' + color.substring(3, 4)) / 15];
        }
    }

    fb.HSLToRGB = function(hsl) {
        var m1, m2, r, g, b;
        var h = hsl[0],
            s = hsl[1],
            l = hsl[2];
        m2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;
        return [this.hueToRGB(m1, m2, h + 0.33333),
            this.hueToRGB(m1, m2, h),
            this.hueToRGB(m1, m2, h - 0.33333)];
    };

    fb.hueToRGB = function(m1, m2, h) {
        h = (h < 0) ? h + 1 : ((h > 1) ? h - 1 : h);
        if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1) return m2;
        if (h * 3 < 2) return m1 + (m2 - m1) * (0.66666 - h) * 6;
        return m1;
    };

    fb.RGBToHSL = function(rgb) {
        var min, max, delta, h, s, l;
        var r = rgb[0],
            g = rgb[1],
            b = rgb[2];
        min = Math.min(r, Math.min(g, b));
        max = Math.max(r, Math.max(g, b));
        delta = max - min;
        l = (min + max) / 2;
        s = 0;
        if (l > 0 && l < 1) {
            s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));
        }
        h = 0;
        if (delta > 0) {
            if (max == r && max != g) h += (g - b) / delta;
            if (max == g && max != b) h += (2 + (b - r) / delta);
            if (max == b && max != r) h += (4 + (r - g) / delta);
            h /= 6;
        }
        return [h, s, l];
    }

    // Install mousedown handler (the others are set on the document on-demand)
    $('*', e).mousedown(fb.mousedown);

    // Init color
    fb.setColor('#123456');

    // Set linked elements/callback
    if (callback) {
        fb.linkTo(callback);
    }
};
define("taoQtiItem/qtiCreator/editor/styleEditor/farbtastic/farbtastic", function(){});

define('taoQtiItem/qtiCreator/editor/styleEditor/colorSelector',[
    'jquery',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',
    'i18n',
    'taoQtiItem/qtiCreator/editor/styleEditor/farbtastic/farbtastic'
], function ($, styleEditor, __) {
    'use strict'

    // based on http://stackoverflow.com/a/14238466
    // this conversion is required to communicate with farbtastic
    function rgbToHex(color) {
        // undefined can happen when no color is defined for a particular element
        // isString on top of that should cover all sorts of weird input
        if(!_.isString(color)) {
            return color;
        }

        var rgbArr = /rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/i.exec(color);

        // color is not rgb
        if(!_.isArray(rgbArr) || rgbArr.length !== 4) {
            return color;
        }

        return ('#'
            + ('0' + parseInt(rgbArr[1], 10).toString(16)).slice(-2)
            + ('0' + parseInt(rgbArr[2], 10).toString(16)).slice(-2)
            + ('0' + parseInt(rgbArr[3], 10).toString(16)).slice(-2));
    }

    var colorSelector = function () {
        var colorPicker = $('#item-editor-color-picker'),
            widget = colorPicker.find('.color-picker'),
            widgetBox = colorPicker.find('#color-picker-container'),
            titleElement =  colorPicker.find('#color-picker-title'),
            input = colorPicker.find('#color-picker-input'),
            resetButtons = colorPicker.find('.reset-button'),
            colorTriggers = colorPicker.find('.color-trigger'),
            colorTriggerLabels = colorPicker.find('label'),
            currentProperty = 'color',
            widgetObj,
            $doc = $(document);



        /**
         * Widget title
         *
         * @param property
         * @param trigger
         */
        var setTitle = function (property, trigger) {
            titleElement.text(trigger.parent().find('label').text());
        };

        /**
         * Trigger button background
         */
        var setTriggerColor = function() {
            colorTriggers.each(function () {
                var $trigger = $(this),
                    target   = $trigger.data('target'),
                    $target  = $(target),
                    style    = styleEditor.getStyle() || {},
                    value;

                // elements have a color from usage of style editor
                if(style[target] && style[target][$trigger.data('value')]) {
                    value = style[target][$trigger.data('value')];
                    $trigger.css('background-color', value);
                    $trigger.attr('title', rgbToHex(value));
                }
                // elements have a default color from tao css
                else if($target.css($trigger.data('value'))) {
                    value = $target.css($trigger.data('value'));
                    $trigger.css('background-color', value);
                    $trigger.attr('title', rgbToHex(value));
                }
                // elements have no color at all
                else {
                    $trigger.css('background-color', '');
                    $trigger.attr('title', __('No value set'));
                }

            });
        };

        widgetObj = $.farbtastic(widget).linkTo(input);

        // event received from modified farbtastic
        widget.on('colorchange.farbtastic', function (e, color) {
            styleEditor.apply(widget.prop('target'), currentProperty, color);
            setTriggerColor();
        });


        // open color picker
        setTriggerColor();
        colorTriggers.add(colorTriggerLabels).on('click', function () {
            var $tmpTrigger = $(this),
                $trigger = (this.nodeName.toLowerCase() === 'label'
                    ? $tmpTrigger.parent().find('.color-trigger')
                    : $tmpTrigger),
                value = $trigger.css('background-color');

            widget.prop('target', $trigger.data('target'));
            widgetBox.hide();
            currentProperty = $trigger.data('value');
            setTitle(currentProperty, $trigger);
            widgetObj.setColor(rgbToHex($trigger.css('background-color')));
            widgetBox.show();
        });

        // close color picker, when clicking somewhere outside or on the x
        $doc.on('mouseup', function(e) {
            if(e.target.className && e.target.className.indexOf('closer') > -1) {
                widgetBox.hide();
                return false;
            }

            if (!widgetBox.is(e.target)
                && widgetBox.has(e.target).length === 0) {
                widgetBox.hide();
                return false;
            }
        });

        // close color picker on escape
        $doc.on('keyup', function(e){
            if (e.keyCode === 27) {
                widgetBox.hide();
                return false;
            }
        });


        // reset to default
        resetButtons.on('click', function () {
            var $this = $(this),
                $colorTrigger = $this.parent().find('.color-trigger'),
                target = $colorTrigger.data('target'),
                value = $colorTrigger.data('value');
            styleEditor.apply(target, value);
            setTriggerColor();
        });


        $doc.on('customcssloaded.styleeditor', setTriggerColor);
    };

    return colorSelector;
});
define('taoQtiItem/qtiCreator/editor/styleEditor/fontSizeChanger',[
    'jquery',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor'
], function ($, styleEditor) {
    'use strict'

    var fontSizeChanger = function () {
        var fontSizeChanger = $('#item-editor-font-size-changer'),
            target = fontSizeChanger.data('target'),
            headSelector = target + ' .item-title',
            bodySelector = target + ' .qti-itemBody',
            headFontSize = parseInt($(headSelector).css('font-size'), 10),
            bodyFontSize = parseInt($(bodySelector).css('font-size'), 10),
            headBodyDiff = headFontSize - bodyFontSize,
            resetButton =  fontSizeChanger.parents('.reset-group').find('[data-role="font-size-reset"]'),
            input = $('#item-editor-font-size-text');
        
        var resizeFont = function() {
            var headFontSize = bodyFontSize + headBodyDiff;
            styleEditor.apply(headSelector, 'font-size', headFontSize.toString() + 'px');
            styleEditor.apply(bodySelector, 'font-size', bodyFontSize.toString() + 'px');
        };

        fontSizeChanger.find('a').on('click', function(e) {
            e.preventDefault();
            if($(this).data('action') === 'reduce') {
                if(bodyFontSize <= 10) {
                    return;
                }
                bodyFontSize--;
            }
            else {
                bodyFontSize++;
            }
            resizeFont();
            input.val(bodyFontSize);
            $(this).parent().blur();
        });

        input.on('keydown', function(e) {
            var c = e.keyCode;
            return (_.contains([8, 37, 39, 46], c)
                || (c >= 48 && c <= 57)
                || (c >= 96 && c <= 105));
        });

        input.on('blur', function() {
            bodyFontSize = parseInt(this.value, 10);
            resizeFont();
        });

        input.on('keydown', function(e) {
            var c = e.keyCode;
            if(c === 13) {
                input.trigger('blur');
            }
        });

        resetButton.on('click', function () {
            input.val('');
            styleEditor.apply(headSelector, 'font-size');
            styleEditor.apply(bodySelector, 'font-size');
        });

        // style loaded from style sheet
        $(document).on('customcssloaded.styleeditor', function() {
            input.val(parseInt($(bodySelector).css('font-size'), 10));
            input.trigger('blur');
        });
    };

    return fontSizeChanger;
});


/*! $.noUiSlider - WTFPL - refreshless.com/nouislider/ */

/*jslint browser: true */
/*jslint devel: true */
/*jslint continue: true */
/*jslint plusplus: true */
/*jslint sub: true */
/*jslint white: true */

// ==ClosureCompiler==
// @externs_url http://refreshless.com/externs/jquery-1.8.js
// @compilation_level ADVANCED_OPTIMIZATIONS
// @warning_level VERBOSE
// ==/ClosureCompiler==

(function( $ ){

	

	var
	// Cache the document selector;
/** @const */ doc = $(document),
	// Namespace for binding and unbinding slider events;
/** @const */ namespace = '.nui',
	// Copy of the current value function;
/** @const */ $val = $.fn.val,
	// Determine the events to bind. IE11 implements pointerEvents without
	// a prefix, which breaks compatibility with the IE10 implementation.
/** @const */ actions = window.navigator.pointerEnabled ? {
		start: 'pointerdown',
		move: 'pointermove',
		end: 'pointerup'
	} : window.navigator.msPointerEnabled ? {
		start: 'MSPointerDown',
		move: 'MSPointerMove',
		end: 'MSPointerUp'
	} : {
		start: 'mousedown touchstart',
		move: 'mousemove touchmove',
		end: 'mouseup touchend'
	},
	// Re-usable list of classes;
/** @const */ Classes = [
/*  0 */  'noUi-target'
/*  1 */ ,'noUi-base'
/*  2 */ ,'noUi-origin'
/*  3 */ ,'noUi-handle'
/*  4 */ ,'noUi-horizontal'
/*  5 */ ,'noUi-vertical'
/*  6 */ ,'noUi-background'
/*  7 */ ,'noUi-connect'
/*  8 */ ,'noUi-ltr'
/*  9 */ ,'noUi-rtl'
/* 10 */ ,'noUi-dragable'
/* 11 */ ,''
/* 12 */ ,'noUi-state-drag'
/* 13 */ ,''
/* 14 */ ,'noUi-state-tap'
/* 15 */ ,'noUi-active'
/* 16 */ ,'noUi-extended'
/* 17 */ ,'noUi-stacking'
	],
/** @const */ Formatting = [
/*  0 */  'decimals'
/*  1 */ ,'mark'
/*  2 */ ,'thousand'
/*  3 */ ,'prefix'
/*  4 */ ,'postfix'
/*  5 */ ,'encoder'
/*  6 */ ,'decoder'
/*  7 */ ,'negative'
/*  8 */ ,'negativeBefore'
	],
/** @const */ FormatDefaults = [
/*  0 */  2
/*  1 */ ,'.'
/*  2 */ ,''
/*  3 */ ,''
/*  4 */ ,''
/*  5 */ ,function(a){ return a; }
/*  6 */ ,function(a){ return a; }
/*  7 */ ,'-'
/*  8 */ ,''
	];


// Error handling

	function throwError( message ){
		throw new RangeError('noUiSlider: ' + message);
	}

	// Throw an error if formatting options are incompatible.
	function throwEqualError( F, a, b ) {
		if ( (F[a] || F[b]) && (F[a] === F[b]) ) {
			throwError("(Link) '"+a+"' can't match '"+b+"'.'");
		}
	}


// General helpers

	// Limits a value to 0 - 100
	function limit ( a ) {
		return Math.max(Math.min(a, 100), 0);
	}

	// Round a value to the closest 'to'.
	function closest ( value, to ) {
		return Math.round(value / to) * to;
	}

	// Determine the size of a sub-range in relation to a full range.
	function subRangeRatio ( pa, pb ) {
		return (100 / (pb - pa));
	}


// Type validation

	function typeMatch ( a, b ) {
		return (typeof a) === (typeof b);
	}

	// Test in an object is an instance of jQuery or Zepto.
	function isInstance ( a ) {
		return a instanceof $ || ( $['zepto'] && $['zepto']['isZ'](a) );
	}

	// Checks whether a value is numerical.
	function isNumeric ( a ) {
		return typeof a === 'number' && !isNaN( a ) && isFinite( a );
	}

	// Wraps a variable as an array, if it isn't one yet.
	function asArray ( a ) {
		return $.isArray(a) ? a : [a];
	}


// Class handling

	// Sets a class and removes it after [duration] ms.
	function addClassFor ( element, className, duration ) {
		element.addClass(className);
		setTimeout(function(){
			element.removeClass(className);
		}, duration);
	}

	// Tests if element has a class, adds it if not. Returns original state.
	function getsClass ( element, className ) {

		var has = element.hasClass(className);

		if ( !has ) {
			element.addClass( className );
		}

		return has;
	}


// Value calculation

	// (percentage) How many percent is this value of this range?
	function fromPercentage ( range, value ) {
		return (value * 100) / ( range[1] - range[0] );
	}

	// (percentage) Where is this value on this range?
	function toPercentage ( range, value ) {
		return fromPercentage( range, range[0] < 0 ?
			value + Math.abs(range[0]) :
				value - range[0] );
	}

	// (value) How much is this percentage on this range?
	function isPercentage ( range, value ) {
		return ((value * ( range[1] - range[0] )) / 100) + range[0];
	}

	// (percentage)
	function toStepping ( options, value ) {

		if ( value >= options.xVal.slice(-1)[0] ){
			return 100;
		}

		var j = 1, va, vb, pa, pb;
		while ( value >= options.xVal[j] ){
			j++;
		}

		va = options.xVal[j-1];
		vb = options.xVal[j];
		pa = options.xPct[j-1];
		pb = options.xPct[j];

		return pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));
	}

	// (value)
	function fromStepping ( options, value ) {

		// There is no range group that fits 100
		if ( value >= 100 ){
			return options.xVal.slice(-1)[0];
		}

		var j = 1, va, vb, pa, pb;
		while ( value >= options.xPct[j] ){
			j++;
		}

		va = options.xVal[j-1];
		vb = options.xVal[j];
		pa = options.xPct[j-1];
		pb = options.xPct[j];

		return isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));
	}

	// (percentage) Get the step that applies at a certain value.
	function getStep ( options, value ){

		var j = 1, a, b;
		while ( value >= options.xPct[j] ){
			j++;
		}

		if ( options.snap ) {

			a = options.xPct[j-1];
			b = options.xPct[j];

			if ((value - a) > ((b-a)/2)){
				return b;
			}

			return a;
		}

		if ( !options.xSteps[j-1] ){
			return value;
		}

		return options.xPct[j-1] + closest(
			value - options.xPct[j-1],
			options.xSteps[j-1]
		);
	}


// Event handling

	// Provide a clean event with standardized offset values.
	function fixEvent ( e ) {

		// Prevent scrolling and panning on touch events, while
		// attempting to slide. The tap event also depends on this.
		e.preventDefault();

		// Filter the event to register the type, which can be
		// touch, mouse or pointer. Offset changes need to be
		// made on an event specific basis.
		var  touch = e.type.indexOf('touch') === 0
			,mouse = e.type.indexOf('mouse') === 0
			,pointer = e.type.indexOf('pointer') === 0
			,x,y, event = e;

		// IE10 implemented pointer events with a prefix;
		if ( e.type.indexOf('MSPointer') === 0 ) {
			pointer = true;
		}

		// Get the originalEvent, if the event has been wrapped
		// by jQuery. Zepto doesn't wrap the event.
		if ( e.originalEvent ) {
			e = e.originalEvent;
		}

		if ( touch ) {
			// noUiSlider supports one movement at a time,
			// so we can select the first 'changedTouch'.
			x = e.changedTouches[0].pageX;
			y = e.changedTouches[0].pageY;
		}

		if ( mouse || pointer ) {

			// Polyfill the pageXOffset and pageYOffset
			// variables for IE7 and IE8;
			if( !pointer && window.pageXOffset === undefined ){
				window.pageXOffset = document.documentElement.scrollLeft;
				window.pageYOffset = document.documentElement.scrollTop;
			}

			x = e.clientX + window.pageXOffset;
			y = e.clientY + window.pageYOffset;
		}

		event.points = [x, y];
		event.cursor = mouse;

		return event;
	}


// Organize formatting in an object.

	/** @constructor */
	function Format( options ){

		// If no settings where provided, the defaults will be loaded.
		if ( options === undefined ){
			options = {};
		}

		if ( typeof options !== 'object' ){
			throwError("(Format) 'format' option must be an object.");
		}

		var settings = {};

		// Copy all values into a new object.
		$(Formatting).each(function(i, val){

			if ( options[val] === undefined ){

				settings[val] = FormatDefaults[i];

			// When we aren't loading defaults, validate the entry.
			} else if ( typeMatch(options[val],  FormatDefaults[i]) ) {

				// Support for up to 7 decimals.
				// More can't be guaranteed due to floating point issues.
				if ( val === 'decimals' ){
					if ( options[val] < 0 || options[val] > 7 ){
						throwError("(Format) 'format.decimals' option must be between 0 and 7.");
					}
				}

				settings[val] = options[val];

			// If the value isn't valid, emit an error.
			} else {
				throwError("(Format) 'format."+val+"' must be a " + typeof FormatDefaults[i] + ".");
			}
		});

		// Some values can't be extracted from a
		// string if certain combinations are present.
		throwEqualError(settings, 'mark', 'thousand');
		throwEqualError(settings, 'prefix', 'negative');
		throwEqualError(settings, 'prefix', 'negativeBefore');

		this.settings = settings;
	}

	// Shorthand for internal value get
	Format.prototype.v = function ( a ) {
		return this.settings[a];
	};

	Format.prototype.to = function ( number ) {

		function reverse ( a ) {
			return a.split('').reverse().join('');
		}

		number = this.v('encoder')( number );

		var negative = '', preNegative = '', base = '', mark = '';

		if ( number < 0 ) {
			negative = this.v('negative');
			preNegative = this.v('negativeBefore');
		}

		// Round to proper decimal count
		number = Math.abs(number).toFixed( this.v('decimals') ).toString();
		number = number.split('.');

		// Rounding away decimals might cause a value of -0
		// when using very small ranges. Remove those cases.
		if ( parseFloat(number) === 0 ) {
			number[0] = '0';
		}

		// Group numbers in sets of three.
		if ( this.v('thousand') ) {
			base = reverse(number[0]).match(/.{1,3}/g);
			base = reverse(base.join(reverse( this.v('thousand') )));
		} else {
			base = number[0];
		}

		// Ignore the decimal separator if decimals are set to 0.
		if ( this.v('mark') && number.length > 1 ) {
			mark = this.v('mark') + number[1];
		}

		// Return the finalized formatted number.
		return preNegative +
			this.v('prefix') +
			negative +
			base +
			mark +
			this.v('postfix');
	};

	Format.prototype.from = function ( input ) {

		function esc(s){
			return s.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g, '\\$&');
		}

		var isNeg;
		// The set request might want to ignore this handle.
		// Test for 'undefined' too, as a two-handle slider
		// can still be set with an integer.
		if( input === null || input === undefined ) {
			return false;
		}

		// Remove formatting and set period for float parsing.
		input = input.toString();

		// Replace the preNegative indicator.
		isNeg = input.replace(new RegExp('^' + esc( this.v('negativeBefore') )), '');

		// Check if the value changed by removing the negativeBefore symbol.
		if( input !== isNeg ) {
			input = isNeg;
			isNeg = '-';
		} else {
			isNeg = '';
		}

		// If prefix is set and the number is actually prefixed.
		input = input.replace(new RegExp('^'+esc( this.v('prefix') )), '');

		// Only replace if a negative sign is set.
		if ( this.v['negative'] ) {

			// Reset isNeg to prevent double '-' insertion.
			isNeg = '';

			// Reset the negative sign to '-'
			input = input.replace(new RegExp('^'+esc( this.v('negative') )), '-');
		}

		// Clean the input string
		input = input
		// If postfix is set and the number is postfixed.
			.replace( new RegExp(esc( this.v('postfix') ) + '$'), '')
		// Remove the separator every three digits.
			.replace( new RegExp(esc( this.v('thousand') ), 'g'), '')
		// Set the decimal separator back to period.
			.replace( this.v('mark'), '.');

		// Run the user defined decoder. Returns input by default.
		input = this.v('decoder')( parseFloat( isNeg + input ) );

		// Ignore invalid input
		if (isNaN( input )) {
			return false;
		}

		return input;
	};


// Serialization target

/** @constructor */
	function Link( entry, update ){

		// Make sure Link isn't called as a function, in which case
		// the 'this' scope would be the window.
		if ( !(this instanceof Link) ) {
			throw new Error( "Link: " +
				"Don't use Link as a function. " +
				"Use the 'new' keyword.");
		}

		if ( !entry ) {
			throw new RangeError("Link: missing parameters.");
		}

		// Write all formatting to this object.
		// No validation needed, as we'll merge these with the parent
		// format options first.
		this.formatting = entry['format'] || {};

		// Store the update option.
		this.update = !update;

		// In IE < 9, .bind() isn't available, need this link in .change().
	var that = this,

		// Get values from the input.
		target = entry['target'] || function(){},
		method = entry['method'],

		// Find the type of this link.
		isTooltip = ( typeof target === 'string' && target.indexOf('-tooltip-') === 0 ),
		isHidden = ( typeof target === 'string' && target.indexOf('-') !== 0 ),
		isMethod = ( typeof target === 'function' ),
		is$ = ( isInstance(target) ),
		isInput = ( is$ && target.is('input, select, textarea') ),
		methodIsFunction = ( is$ && typeof method === 'function' ),
		methodIsName = ( is$ && typeof method === 'string' && target[method] );

		// If target is a string, a new hidden input will be created.
		if ( isTooltip ) {

			// By default, use the 'html' method.
			this.method = method || 'html';

			// Use jQuery to create the element
			this.el = $( target.replace('-tooltip-', '') || '<div/>' )[0];

			return;
		}

		// If the string doesn't begin with '-', which is reserved, add a new hidden input.
		if ( isHidden ) {

			this.method = 'val';

			this.el = document.createElement('input');
			this.el.name = target;
			this.el.type = 'hidden';

			return;
		}

		// The target can also be a function, which will be called.
		if ( isMethod ) {
			this.target = false;
			this.method = target;
			return;
		}

		// If the target is and $ element.
		if ( is$ ) {

			// The method must exist on the element.
			if ( method && ( methodIsFunction || methodIsName ) ) {
				this.target = target;
				this.method = method;
				return;
			}

			// If a jQuery/Zepto input element is provided, but no method is set,
			// the element can assume it needs to respond to 'change'...
			if ( !method && isInput ) {

				// Default to .val if this is an input element.
				this.method = 'val';
				this.target = target;

				// Set the slider to a new value on change.
				this.target.on('change', function( e ){

					// Returns null array.
					function at(a,b,c){
						return [c?a:b, c?b:a];
					}

					var output = at(null, $(e.target).val(), that.N);

					that.obj.val(output, { 'link': that });
				});

				return;
			}

			// ... or not.
			if ( !method && !isInput ) {

				// Default arbitrarily to 'html'.
				this.method = 'html';
				this.target = target;

				return;
			}
		}

		throw new RangeError("Link: Invalid Link.");
	}

	// Provides external items with the slider value.
	Link.prototype.write = function ( options, value, handle, slider, update ) {

		// Don't synchronize this Link.
		if ( this.update && update === false ) {
			return;
		}

		// Convert the value to the slider stepping/range.
		value = fromStepping( options, value );

		// Format values for display.
		value = this.format( value );

		// Store the numerical value.
		this.saved = value;

		// Branch between serialization to a function or an object.
		if ( typeof this.method === 'function' ) {
			// When target is undefined, the target was a function.
			// In that case, provided the slider as the calling scope.
			// Use [0] to get the DOM element, not the $ instance.
			this.method.call( this.target[0] || slider[0], value, handle, slider );
		} else {
			this.target[ this.method ]( value, handle, slider );
		}
	};

	// Parses slider value to user defined display.
	Link.prototype.format = function ( a ) {
		return this.formatting.to(a);
	};

	// Converts a formatted value back to a real number.
	Link.prototype.valueOf = function ( a ) {
		return this.formatting.from(a);
	};


// Input validation

	function testStep ( parsed, entry ) {

		if ( !isNumeric( entry ) ) {
			throwError("'step' is not numeric.");
		}

		// The step option can still be used to set stepping
		// for linear sliders. Overwritten if set in 'range'.
		parsed.xSteps[0] = entry;
	}

	function testRange ( parsed, entry ) {

		// Filter incorrect input.
		if ( typeof entry !== 'object' || $.isArray(entry) ) {
			throwError("'range' is not an object.");
		}

		// Loop all entries.
		$.each( entry, function ( index, value ) {

			var percentage;

			// Wrap numerical input in an array.
			if ( typeof value === "number" ) {
				value = [value];
			}

			// Reject any invalid input.
			if ( !$.isArray( value ) ){
				throwError("'range' contains invalid value.");
			}

			// Covert min/max syntax to 0 and 100.
			if ( index === 'min' ) {
				percentage = 0;
			} else if ( index === 'max' ) {
				percentage = 100;
			} else {
				percentage = parseFloat( index );
			}

			// Check for correct input.
			if ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {
				throwError("'range' value isn't numeric.");
			}

			// Store values.
			parsed.xPct.push( percentage );
			parsed.xVal.push( value[0] );

			// NaN will evaluate to false too, but to keep
			// logging clear, set step explicitly. Make sure
			// not to override the 'step' setting with false.
			if ( !percentage ) {
				if ( !isNaN( value[1] ) ) {
					parsed.xSteps[0] = value[1];
				}
			} else {
				parsed.xSteps.push( isNaN(value[1]) ? false : value[1] );
			}
		});

		$.each(parsed.xSteps, function(i,n){

			// Ignore 'false' stepping.
			if ( !n ) {
				return true;
			}

			// Check if step fits. Not required, but this might serve some goal.
			// !((parsed.xVal[i+1] - parsed.xVal[i]) % n);

			// Factor to range ratio
			parsed.xSteps[i] = fromPercentage([
				 parsed.xVal[i]
				,parsed.xVal[i+1]
			], n) / subRangeRatio (
				parsed.xPct[i],
				parsed.xPct[i+1] );
		});
	}

	function testStart ( parsed, entry ) {

		if ( typeof entry === "number" ) {
			entry = [entry];
		}

		// Validate input. Values aren't tested, the internal Link will do
		// that and provide a valid location.
		if ( !$.isArray( entry ) || !entry.length || entry.length > 2 ) {
			throwError("'start' option is incorrect.");
		}

		// Store the number of handles.
		parsed.handles = entry.length;

		// When the slider is initialized, the .val method will
		// be called with the start options.
		parsed.start = entry;
	}

	function testSnap ( parsed, entry ) {

		// Enforce 100% stepping within subranges.
		parsed.snap = entry;

		if ( typeof entry !== 'boolean' ){
			throwError("'snap' option must be a boolean.");
		}
	}

	function testConnect ( parsed, entry ) {

		if ( entry === 'lower' && parsed.handles === 1 ) {
			parsed.connect = 1;
		} else if ( entry === 'upper' && parsed.handles === 1 ) {
			parsed.connect = 2;
		} else if ( entry === true && parsed.handles === 2 ) {
			parsed.connect = 3;
		} else if ( entry === false ) {
			parsed.connect = 0;
		} else {
			throwError("'connect' option was doesn't match handle count.");
		}
	}

	function testOrientation ( parsed, entry ) {

		// Set orientation to an a numerical value for easy
		// array selection.
		switch ( entry ){
		  case 'horizontal':
			parsed.ort = 0;
			break;
		  case 'vertical':
			parsed.ort = 1;
			break;
		  default:
			throwError("'orientation' option is invalid.");
		}
	}

	function testMargin ( parsed, entry ) {

		if ( parsed.xPct.length > 2 ) {
			throwError("'margin' option is only supported on linear sliders.");
		}

		// Parse value to range and store. As xVal is checked
		// to be no bigger than 2, use it as range.
		parsed.margin = fromPercentage(parsed.xVal, entry);

		if ( !isNumeric(entry) ){
			throwError("'margin' option must be numeric.");
		}
	}

	function testDirection ( parsed, entry ) {

		// Set direction as a numerical value for easy parsing.
		// Invert connection for RTL sliders, so that the proper
		// handles get the connect/background classes.
		switch ( entry ) {
		  case 'ltr':
			parsed.dir = 0;
			break;
		  case 'rtl':
			parsed.dir = 1;
			parsed.connect = [0,2,1,3][parsed.connect];
			break;
		  default:
			throwError("'direction' option was not recognized.");
		}
	}

	function testBehaviour ( parsed, entry ) {

		// Make sure the input is a string.
		if ( typeof entry !== 'string' ) {
			throwError("'behaviour' must be a string containing options.");
		}

		// Check if the string contains any keywords.
		// None are required.
		var tap = entry.indexOf('tap') >= 0,
			extend = entry.indexOf('extend') >= 0,
			drag = entry.indexOf('drag') >= 0,
			fixed = entry.indexOf('fixed') >= 0,
			snap = entry.indexOf('snap') >= 0;

		parsed.events = {
			tap: tap || snap,
			extend: extend,
			drag: drag,
			fixed: fixed,
			snap: snap
		};
	}

	function testSerialization ( parsed, entry, sliders ) {

		parsed.ser = [ entry['lower'], entry['upper'] ];
		parsed.formatting = new Format( entry['format'] );

		$.each( parsed.ser, function( i, a ){

			// Check if the provided option is an array.
			if ( !$.isArray(a) ) {
				throwError("'serialization."+(!i?'lower':'upper')+"' must be an array.");
			}

			$.each(a, function(){

				// Check if entry is a Link.
				if ( !(this instanceof Link) ) {
					throwError("'serialization."+(!i?'lower':'upper')+"' can only contain Link instances.");
				}

				// Assign other properties.
				this.N = i;
				this.obj = sliders;
				this.scope = this.scope || sliders;

				// Run internal validator.
				this.formatting = new Format($.extend({}
					,entry['format']
					,this.formatting
				));
			});
		});

		// If the slider has two handles and is RTL,
		// reverse the serialization input. For one handle,
		// lower is still lower.
		if ( parsed.dir && parsed.handles > 1 ) {
			parsed.ser.reverse();
		}
	}

	// Test all developer settings and parse to assumption-safe values.
	function test ( options, sliders ){

	/*	Every input option is tested and parsed. This'll prevent
		endless validation in internal methods. These tests are
		structured with an item for every option available. An
		option can be marked as required by setting the 'r' flag.
		The testing function is provided with three arguments:
			- The provided value for the option;
			- A reference to the options object;
			- The name for the option;

		The testing function returns false when an error is detected,
		or true when everything is OK. It can also modify the option
		object, to make sure all values can be correctly looped elsewhere. */

		var parsed = {
			 xPct: []
			,xVal: []
			,xSteps: [ false ]
			,margin: 0
		}, tests;

		tests = {
			'step': { r: false, t: testStep },
			'range': { r: true, t: testRange },
			'start': { r: true, t: testStart },
			'snap': { r: false, t: testSnap },
			'connect': { r: true, t: testConnect },
			'orientation': { r: false, t: testOrientation },
			'margin': { r: false, t: testMargin },
			'direction': { r: true, t: testDirection },
			'behaviour': { r: true, t: testBehaviour },
			'serialization': { r: true, t: testSerialization }
		};

		// Set defaults where applicable.
		options = $.extend({
			 'connect': false
			,'direction': 'ltr'
			,'behaviour': 'tap'
			,'orientation': 'horizontal'
		}, options);

		// Make sure the test for serialization runs.
		options['serialization'] = $.extend({
			 'lower': []
			,'upper': []
			,'format': {}
		}, options['serialization']);

		// Run all options through a testing mechanism to ensure correct
		// input. It should be noted that options might get modified to
		// be handled properly. E.g. wrapping integers in arrays.
		$.each( tests, function( name, test ){

			if ( options[name] === undefined ) {
				if ( test.r ) {
					throwError("'" + name + "' is required.");
				} else {
					return true;
				}
			}

			test.t( parsed, options[name], sliders );
		});

		// Pre-define the styles.
		parsed.style = parsed.ort ? 'top' : 'left';

		return parsed;
	}


// DOM additions

	// Append a handle to the base.
	function addHandle ( options, index ) {

		var handle = $('<div><div/></div>').addClass( Classes[2] ),
			additions = [ '-lower', '-upper' ];

		if ( options.dir ) {
			additions.reverse();
		}

		handle.children().addClass(
			Classes[3] + " " + Classes[3]+additions[index]
		);

		return handle;
	}

	// Create a copy of an element-creating Link.
	function addElement ( handle, link ) {

		// If the Link requires creation of a new element,
		// create this element and return a new Link instance.
		if ( link.el ) {
			link = new Link({
				'target': $(link.el).clone().appendTo( handle ),
				'method': link.method,
				'format': link.formatting
			}, true);
		}

		// Otherwise, return the reference.
		return link;
	}

	// Loop all links for a handle.
	function addElements ( elements, handle, formatting ) {

		var index, list = [];

		// Use the Link interface to provide unified
		// formatting for the .val() method.
		list.push(
			new Link({
				'format': formatting
			}, true)
		);

		// Loop all links in either 'lower' or 'upper'.
		for ( index = 0; index < elements.length; index++ ) {
			list.push(addElement(handle, elements[index]));
		}

		return list;
	}

	// Go over all Links and assign them to a handle.
	function addLinks ( options, handles ) {

		var index, links = [];

		// Copy the links into a new array, instead of modifying
		// the 'options.ser' list. This allows replacement of the invalid
		// '.el' Links, while the others are still passed by reference.
		for ( index = 0; index < options.handles; index++ ) {

			// Append a new array.
			links[index] = addElements(
				options.ser[index],
				handles[index].children(),
				options.formatting
			);
		}

		return links;
	}

	// Add the proper connection classes.
	function addConnection ( connect, target, handles ) {

		// Apply the required connection classes to the elements
		// that need them. Some classes are made up for several
		// segments listed in the class list, to allow easy
		// renaming and provide a minor compression benefit.
		switch ( connect ) {
			case 1:	target.addClass( Classes[7] );
					handles[0].addClass( Classes[6] );
					break;
			case 3: handles[1].addClass( Classes[6] );
					/* falls through */
			case 2: handles[0].addClass( Classes[7] );
					/* falls through */
			case 0: target.addClass(Classes[6]);
					break;
		}
	}

	// Add handles and loop Link elements.
	function addHandles ( options, base ) {

		var index, handles = [];

		// Append handles.
		for ( index = 0; index < options.handles; index++ ) {

			// Keep a list of all added handles.
			handles.push( addHandle( options, index ).appendTo(base) );
		}

		return handles;
	}

	// Initialize a single slider.
	function addSlider ( options, target ) {

		// Apply classes and data to the target.
		target.addClass([
			Classes[0],
			Classes[8 + options.dir],
			Classes[4 + options.ort]
		].join(' '));

		return $('<div/>').appendTo(target).addClass( Classes[1] );
	}


// Slider scope

function closure ( target, options, originalOptions ){

// Internal variables

	// All variables local to 'closure' are marked $.
	var $Target = $(target),
		$Locations = [-1, -1],
		$Base,
		$Serialization,
		$Handles;

	// Shorthand for base dimensions.
	function baseSize ( ) {
		return $Base[['width', 'height'][options.ort]]();
	}


// External event handling

	function fireEvents ( events ) {

		// Use the external api to get the values.
		// Wrap the values in an array, as .trigger takes
		// only one additional argument.
		var index, values = [ $Target.val() ];

		for ( index = 0; index < events.length; index++ ){
			$Target.trigger(events[index], values);
		}
	}


// Handle placement

	// Test suggested values and apply margin, step.
	function setHandle ( handle, to, delimit ) {

		var n = handle[0] !== $Handles[0][0] ? 1 : 0,
			lower = $Locations[0] + options.margin,
			upper = $Locations[1] - options.margin;

		// Don't delimit range dragging.
		if ( delimit && $Handles.length > 1 ) {
			to = n ? Math.max( to, lower ) : Math.min( to, upper );
		}

		// Handle the step option.
		if ( to < 100 ){
			to = getStep(options, to);
		}

		// Limit to 0/100 for .val input, trim anything beyond 7 digits, as
		// JavaScript has some issues in its floating point implementation.
		to = limit(parseFloat(to.toFixed(7)));

		// Return falsy if handle can't move. False for 0 or 100 limit,
		// '0' for limiting by another handle.
		if ( to === $Locations[n] ) {
			if ( $Handles.length === 1 ) {
				return false;
			}
			return ( to === lower || to === upper ) ? 0 : false;
		}

		// Set the handle to the new position.
		handle.css( options.style, to + '%' );

		// Force proper handle stacking
		if ( handle.is(':first-child') ) {
			handle.toggleClass(Classes[17], to > 50 );
		}

		// Update locations.
		$Locations[n] = to;

		// Invert the value if this is a right-to-left slider.
		if ( options.dir ) {
			to = 100 - to;
		}

		// Write values to serialization Links.
		// Convert the value to the correct relative representation.
		$($Serialization[n]).each(function(){
			this.write( options, to, handle.children(), $Target );
		});

		return true;
	}

	// Delimit proposed values for handle positions.
	function getPositions ( a, b, delimit ) {

		// Add movement to current position.
		var c = a + b[0], d = a + b[1];

		// Only alter the other position on drag,
		// not on standard sliding.
		if ( delimit ) {
			if ( c < 0 ) {
				d += Math.abs(c);
			}
			if ( d > 100 ) {
				c -= ( d - 100 );
			}

			// Limit values to 0 and 100.
			return [limit(c), limit(d)];
		}

		return [c,d];
	}

	// Handles movement by tapping.
	function jump ( handle, to, instant ) {

		if ( !instant ) {
			// Flag the slider as it is now in a transitional state.
			// Transition takes 300 ms, so re-enable the slider afterwards.
			addClassFor( $Target, Classes[14], 300 );
		}

		// Move the handle to the new position.
		setHandle( handle, to, false );

		fireEvents(['slide', 'set', 'change']);
	}


// Events

	// Handler for attaching events trough a proxy.
	function attach ( events, element, callback, data ) {

		// Add the noUiSlider namespace to all events.
		events = events.replace( /\s/g, namespace + ' ' ) + namespace;

		// Bind a closure on the target.
		return element.on( events, function( e ){

			// jQuery and Zepto handle unset attributes differently.
			var disabled = $Target.attr('disabled');
				disabled = !( disabled === undefined || disabled === null );

			// Test if there is anything that should prevent an event
			// from being handled, such as a disabled state or an active
			// 'tap' transition.
			if( $Target.hasClass( Classes[14] ) || disabled ) {
				return false;
			}

			e = fixEvent(e);
			e.calcPoint = e.points[ options.ort ];

			// Call the event handler with the event [ and additional data ].
			callback ( e, data );
		});
	}

	// Handle movement on document for handle and range drag.
	function move ( event, data ) {

		var handles = data.handles || $Handles, positions, state = false,
			proposal = ((event.calcPoint - data.start) * 100) / baseSize(),
			h = handles[0][0] !== $Handles[0][0] ? 1 : 0;

		// Calculate relative positions for the handles.
		positions = getPositions( proposal, data.positions, handles.length > 1);

		state = setHandle ( handles[0], positions[h], handles.length === 1 );

		if ( handles.length > 1 ) {
			state = setHandle ( handles[1], positions[h?0:1], false ) || state;
		}

		// Fire the 'slide' event if any handle moved.
		if ( state ) {
			fireEvents(['slide']);
		}
	}

	// Unbind move events on document, call callbacks.
	function end ( event ) {

		// The handle is no longer active, so remove the class.
		$('.' + Classes[15]).removeClass(Classes[15]);

		// Remove cursor styles and text-selection events bound to the body.
		if ( event.cursor ) {
			$('body').css('cursor', '').off( namespace );
		}

		// Unbind the move and end events, which are added on 'start'.
		doc.off( namespace );

		// Remove dragging class.
		$Target.removeClass(Classes[12]);

		// Fire the change and set events.
		fireEvents(['set', 'change']);
	}

	// Bind move events on document.
	function start ( event, data ) {

		// Mark the handle as 'active' so it can be styled.
		if( data.handles.length === 1 ) {
			data.handles[0].children().addClass(Classes[15]);
		}

		// A drag should never propagate up to the 'tap' event.
		event.stopPropagation();

		// Attach the move event.
		attach ( actions.move, doc, move, {
			start: event.calcPoint,
			handles: data.handles,
			positions: [
				$Locations[0],
				$Locations[$Handles.length - 1]
			]
		});

		// Unbind all movement when the drag ends.
		attach ( actions.end, doc, end, null );

		// Text selection isn't an issue on touch devices,
		// so adding cursor styles can be skipped.
		if ( event.cursor ) {

			// Prevent the 'I' cursor and extend the range-drag cursor.
			$('body').css('cursor', $(event.target).css('cursor'));

			// Mark the target with a dragging state.
			if ( $Handles.length > 1 ) {
				$Target.addClass(Classes[12]);
			}

			// Prevent text selection when dragging the handles.
			$('body').on('selectstart' + namespace, false);
		}
	}

	// Move closest handle to tapped location.
	function tap ( event ) {

		var location = event.calcPoint, total = 0, to;

		// The tap event shouldn't propagate up and cause 'edge' to run.
		event.stopPropagation();

		// Add up the handle offsets.
		$.each( $Handles, function(){
			total += this.offset()[ options.style ];
		});

		// Find the handle closest to the tapped position.
		total = ( location < total/2 || $Handles.length === 1 ) ? 0 : 1;

		location -= $Base.offset()[ options.style ];

		// Calculate the new position.
		to = ( location * 100 ) / baseSize();

		// Find the closest handle and calculate the tapped point.
		// The set handle to the new position.
		jump( $Handles[total], to, options.events.snap );

		if ( options.events.snap ) {
			start(event, { handles: [$Handles[total]] });
		}
	}

	// Move handle to edges when target gets tapped.
	function edge ( event ) {

		var i = event.calcPoint < $Base.offset()[ options.style ],
			to = i ? 0 : 100;

		i = i ? 0 : $Handles.length - 1;

		jump( $Handles[i], to, false );
	}

	// Attach events to several slider parts.
	function events ( behaviour ) {

		var i, drag;

		// Attach the standard drag event to the handles.
		if ( !behaviour.fixed ) {

			for ( i = 0; i < $Handles.length; i++ ) {

				// These events are only bound to the visual handle
				// element, not the 'real' origin element.
				attach ( actions.start, $Handles[i].children(), start, {
					handles: [ $Handles[i] ]
				});
			}
		}

		// Attach the tap event to the slider base.
		if ( behaviour.tap ) {
			attach ( actions.start, $Base, tap, {
				handles: $Handles
			});
		}

		// Extend tapping behaviour to target
		if ( behaviour.extend ) {

			$Target.addClass( Classes[16] );

			if ( behaviour.tap ) {
				attach ( actions.start, $Target, edge, {
					handles: $Handles
				});
			}
		}

		// Make the range dragable.
		if ( behaviour.drag ){

			drag = $Base.find( '.' + Classes[7] ).addClass( Classes[10] );

			// When the range is fixed, the entire range can
			// be dragged by the handles. The handle in the first
			// origin will propagate the start event upward,
			// but it needs to be bound manually on the other.
			if ( behaviour.fixed ) {
				drag = drag.add($Base.children().not( drag ).children());
			}

			attach ( actions.start, drag, start, {
				handles: $Handles
			});
		}
	}


// Initialize slider

	// Throw an error if the slider was already initialized.
	if ( !$Target.is(':empty') ) {
		throw new Error('Slider was already initialized.');
	}

	// Create the base element, initialise HTML and set classes.
	// Add handles and links.
	$Base = addSlider( options, $Target );
	$Handles = addHandles( options, $Base );
	$Serialization = addLinks( options, $Handles );

	// Set the connect classes.
	addConnection ( options.connect, $Target, $Handles );

	// Attach user events.
	events( options.events );


// Methods

	// Set the slider value.
	target.vSet = function ( values, callback, link, update, animate ){

		var i, to;

		// The RTL settings is implemented by reversing the front-end,
		// internal mechanisms are the same.
		if ( options.dir && options.handles > 1 ) {
			values.reverse();
		}

		// Animation is optional.
		if ( animate ) {
			addClassFor( $Target, Classes[14], 300 );
		}

		// If there are multiple handles to be set run the setting
		// mechanism twice for the first handle, to make sure it
		// can be bounced of the second one properly.
		for ( i = 0; i < ( $Handles.length > 1 ? 3 : 1 ); i++ ) {

			to = link || $Serialization[i%2][0];
			to = to.valueOf( values[i%2] );

			if ( to === false ) {
				continue;
			}

			// Calculate the new handle position
			to = toStepping( options, to );

			// Invert the value if this is a right-to-left slider.
			if ( options.dir ) {
				to = 100 - to;
			}

			// Force delimitation.
			if ( setHandle( $Handles[i%2], to, true ) === true ) {
				continue;
			}

			// Reset the input if it doesn't match the slider.
			$($Serialization[i%2]).each(function(){
				this.write(
					options,
					$Locations[i%2],
					$Handles[i%2].children(),
					$Target,
					update
				);
			});
		}

		// Optionally fire the 'set' event.
		if( callback === true ) {
			fireEvents(['set']);
		}

		return this;
	};

	// Get the slider value.
	target.vGet = function ( ){

		var i, retour = [];

		// Get the value from all handles.
		for ( i = 0; i < options.handles; i++ ){
			retour[i] = $Serialization[i][0].saved;
		}

		// If only one handle is used, return a single value.
		if ( retour.length === 1 ){
			return retour[0];
		}

		if ( options.dir && options.handles > 1 ) {
			return retour.reverse();
		}

		return retour;
	};

	// Destroy the slider and unbind all events.
	target.destroy = function ( ){

		// Loop all linked serialization objects and unbind all
		// events in the noUiSlider namespace.
		$.each($Serialization, function(){
			$.each(this, function(){
				// Won't remove 'change' when bound implicitly.
				if ( this.target ) {
					this.target.off( namespace );
				}
			});
		});

		// Unbind events on the slider, remove all classes and child elements.
		$(this).off(namespace)
			.removeClass(Classes.join(' '))
			.empty();

		// Return the original options from the closure.
		return originalOptions;
	};


// Value setting

	// Use the public value method to set the start values.
	$Target.val( options.start );
}


// Access points

	// Run the standard initializer
	function initialize ( originalOptions ) {
		// Throw error if group is empty.
        if (!this.length) {
            return;
			throwError("Can't initialize slider on empty selection.");
		}

		// Test the options once, not for every slider.
		var options = test( originalOptions, this );

		// Loop all items, and provide a new closed-scope environment.
		return this.each(function(){
			closure(this, options, originalOptions);
		});
	}

	// Destroy the slider, then re-enter initialization.
	function rebuild ( options ) {

		return this.each(function(){

			// Get the current values from the slider,
			// including the initialization options.
			var values = $(this).val(),
				originalOptions = this.destroy(),

				// Extend the previous options with the newly provided ones.
				newOptions = $.extend( {}, originalOptions, options );

			// Run the standard initializer.
			$(this).noUiSlider( newOptions );

			// If the start option hasn't changed,
			// reset the previous values.
			if ( originalOptions.start === newOptions.start ) {
				$(this).val(values);
			}
		});
	}


	// Expose serialization constructor.
	/** @expose */
	$.noUiSlider = { 'Link': Link };

	// Extend jQuery/Zepto with the noUiSlider method.
	/** @expose */
	$.fn.noUiSlider = function ( options, re ) {
		return ( re ? rebuild : initialize ).call(this, options);
	};

	$.fn.val = function ( ) {

		// Convert the function arguments to an array.
		var args = Array.prototype.slice.call( arguments, 0 ),
			set, link, update, animate;

		// Test if there are arguments, and if not, call the 'get' method.
		if ( !args.length ) {

			// Determine whether to use the native val method.
			if ( this.hasClass(Classes[0]) ) {
				return this[0].vGet();
			}

			return $val.apply( this );
		}

		// Extract modifiers for value method.
		if ( typeof args[1] === 'object' ) {
			set = args[1]['set'];
			link = args[1]['link'];
			update = args[1]['update'];
			animate = args[1]['animate'];

		// Support the 'true' option.
		} else if ( args[1] === true ) {
			set = true;
		}

		// Loop all individual items, and handle setting appropriately.
		return this.each(function(){

			if ( $(this).hasClass(Classes[0]) ) {
				this.vSet( asArray(args[0]), set, link, update, animate );
			} else {
				$val.apply( $(this), args );
			}
		});
	};

}( window['jQuery'] || window['Zepto'] ));

define("nouislider", function(){});

define('taoQtiItem/qtiCreator/editor/styleEditor/itemResizer',[
    'jquery',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',
    'nouislider',
    'jqueryui'

], function ($, styleEditor) {
    'use strict'



    /**
     * Adapt the image editor to the target screen the students will be using
     */
    var itemResizer = function () {

        var itemResizer = $('#item-editor-item-resizer'),
            target = itemResizer.data('target'),
            $target = $(target),
            targetWidth = $target.width(),
            sliderBox = itemResizer.find('.slider-box'),
            slider = itemResizer.find('#item-editor-item-resizer-slider'),
            input = $('#item-editor-item-resizer-text'),
            resetButton =  itemResizer.find('[data-role="item-width-reset"]'),
            sliderSettings = {
                range : {
                    min: Math.min(768, targetWidth),
                    max: Math.max(1200, targetWidth)
                },
                start: targetWidth
            };


        var reset = function() {
            itemResizer.find('[value="no-slider"]').trigger('click');
        };

        /**
         * Resize item
         *
         * @param val int|string
         */
        var resizeItem = function(val) {
            // to make sure the value can come as int or string
            val = parseInt(val).toString() + 'px';
            styleEditor.apply(target, 'width', val);
            styleEditor.apply(target, 'max-width', 'none');
        };

        /**
         * Initialize radio buttons
         */
        itemResizer.find('[name="item-width-prompt"]').on('click', function() {
            // user intends to resize the item
            if(this.value === 'slider') {
                resizeItem($target.width());
                input.val($target.width());
                sliderBox.slideDown();
            }
            // user wants to use default
            else {
                slider.val(sliderSettings.start);
                sliderBox.slideUp();
                input.val('');

                styleEditor.apply(target, 'width');
                styleEditor.apply(target, 'max-width');
            }
        });


        slider.noUiSlider(sliderSettings);
        slider.on('slide', function() {
            var value = Math.round(slider.val());
            input.val(value);
            resizeItem(value);
        });

        input.on('keydown', function(e) {
            var c = e.keyCode;
            return (_.contains([8, 37, 39, 46], c)
                || (c >= 48 && c <= 57)
                || (c >= 96 && c <= 105));
        });

        input.on('blur', function() {
            resizeItem(this.value);
        });

        resetButton.on('click', reset);
        $(document).on('customcssloaded.styleeditor', function(e, style) {
            
            //@todo : to be fixed ! currently disabled because keep triggering error "style is undefined"
            return;
            
            var width;
            if(style[target] && style[target].width) {
                width = parseInt(style[target].width, 10);
                input.val(width);
                slider.val(width);
                itemResizer.find('[value="slider"]').trigger('click');
            }
        });
    };
    return itemResizer;
});
define('taoQtiItem/qtiCreator/editor/styleEditor/styleSheetToggler',[
    'jquery',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',
    'i18n',
    'helpers',
    'lodash',
    'ui/resourcemgr'
], function ($, styleEditor, __, helpers, _) {
    'use strict'

    var styleSheetToggler = (function () {

        var init = function (itemConfig) {

            var cssToggler = $('#style-sheet-toggler'),
                uploader = $('#stylesheet-uploader'),
                customCssToggler = $('[data-custom-css]'),
                getContext = function (trigger) {
                    trigger = $(trigger);
                    var li = trigger.closest('li'),
                        stylesheetObj = li.data('stylesheetObj');

                    return {
                        li: li,
                        isCustomCss: !!li.data('custom-css'),
                        isDisabled: li.find('.icon-preview').hasClass('disabled'),
                        stylesheetObj: stylesheetObj,
                        cssUri: stylesheetObj.attr('href')
                    }

                };


            /**
             * Upload custom stylesheets
             */
            uploader.on('click', function () {

                uploader.resourcemgr({
                    appendContainer: '#item-editor-panel',
                    root: '/',
                    browseUrl: helpers._url('files', 'ItemContent', 'taoItems'),
                    uploadUrl: helpers._url('upload', 'ItemContent', 'taoItems'),
                    deleteUrl: helpers._url('delete', 'ItemContent', 'taoItems'),
                    downloadUrl: helpers._url('download', 'ItemContent', 'taoItems'),
                    params: {
                        uri: itemConfig.uri,
                        lang: itemConfig.lang,
                        filters: 'text/css'
                    },
                    pathParam: 'path',
                    select: function (e, uris) {
                        var i, l = uris.length;
                        for (i = 0; i < l; i++) {
                            styleEditor.addStylesheet(uris[i]);
                        }
                    }
                });
            });

            /**
             * Delete existing style sheet resp. custom styles
             */
            var deleteStylesheet = function (trigger) {
                var context = getContext(trigger),
                    attr = context.isDisabled ? 'disabled-href' : 'href';

                if (confirm(__('Are you sure you want to delete this stylesheet?\nWarning: This action cannot be undone!'))) {
                    styleEditor.getItem().remove();
                    $('link[' + attr + '$="' + context.cssUri + '"]').remove();
                    context.li.remove();
                }
            };


            /**
             * Modify stylesheet title (enable)
             */
            var initLabelEditor = function (trigger) {
                var label = $(trigger),
                    input = label.next('.style-sheet-label-editor');
                label.hide();
                input.show();
            };

            /**
             * Download current stylesheet
             *
             * @param trigger
             */
            var downloadStylesheet = function(trigger) {
                styleEditor.download(getContext(trigger).cssUri);
            };

            /**
             * Modify stylesheet title (save modification)
             */
            var saveLabel = function (trigger) {
                var input = $(trigger),
                    context = getContext(trigger),
                    label = input.prev('.file-label'),
                    title = $.trim(input.val());

                if (!title) {
                    context.stylesheetObj.attr('title', '');
                    return false;
                }

                context.stylesheetObj.attr('title', title);
                input.hide();
                label.html(title).show();
            };

            /**
             * Dis/enable style sheets
             */
            var handleAvailability = function (trigger) {
                var context = getContext(trigger),
                    link,
                    attrTo = 'disabled-href',
                    attrFrom = 'href';

                // custom styles are handled in a style element, not in a link
                if (context.isCustomCss) {
                    if (context.isDisabled) {
                        styleEditor.create();
                        customCssToggler.removeClass('not-available');
                    }
                    else {
                        styleEditor.erase();
                        customCssToggler.addClass('not-available');
                    }
                }
                // all other styles are handled via their link element
                else {
                    if (context.isDisabled) {
                        attrTo = 'href';
                        attrFrom = 'disabled-href';
                    }

                    link = $('link[' + attrFrom + '$="' + context.cssUri + '"]');
                    link.attr(attrTo, link.attr(attrFrom)).removeAttr(attrFrom);
                }

                // add some visual feed back to the triggers
                $(trigger).toggleClass('disabled');
            };

            /**
             * Distribute click events
             */
            cssToggler.on('click', function (e) {
                var target = e.target,
                    className = target.className;

                // distribute click actions
                if (className.indexOf('icon-bin') > -1) {
                    deleteStylesheet(e.target);
                }
                else if (className.indexOf('file-label') > -1) {
                    initLabelEditor(e.target);
                }
                else if (className.indexOf('icon-preview') > -1) {
                    handleAvailability(e.target)
                }
                else if(className.indexOf('icon-download') > -1) {
                    downloadStylesheet(e.target);
                }
            });


            /**
             * Handle renaming on enter
             */
            cssToggler.on('keydown', 'input', function (e) {
                if (e.keyCode === 13) {
                    $(e.target).trigger('blur');
                }
            });

            /**
             * Handle renaming on blur
             */
            cssToggler.on('blur', 'input', function (e) {
                saveLabel(e.target)
            });


        };

        return {
            init: init
        }

    })();

    return styleSheetToggler;
});


define('taoQtiItem/qtiCreator/editor/editor',[
    'jquery'
], function ($) {
    
    

    var editor = (function () {

        var elements = {
            scope: $('#item-editor-scope'),
            toolbar: $('#item-editor-toolbar'),
            toolbarInner: $('#item-editor-toolbar-inner'),
            sidebars: $('.item-editor-sidebar'),
            itemBar: $('#item-editor-item-bar'),
            itemPanel: $('#item-editor-panel')
        };

        // selectors and classes
        var heading = 'h2',
            section = 'section',
            panel   = 'hr, .panel',
            closed  = 'closed',
            ns      = 'accordion';

        /**
         * setup accordion
         */
        var sidebarAccordionInit = function () {

            elements.sidebars.each(function () {
                var $sidebar = $(this),
                    $sections = $sidebar.find(section),
                    $allPanels = $sidebar.children(panel).hide(),
                    $allTriggers = $sidebar.find(heading);


                // setup events
                $allTriggers.each(function () {
                    var $heading = $(this),
                        $section = $heading.parents(section),
                        $panel   = $section.children(panel),
                        $closer = $('<span>', { 'class': 'icon-up'}),
                        $opener = $('<span>', { 'class': 'icon-down'}),
                        action  = $panel.is(':visible') ? 'open' : 'close';

                    $heading.append($closer).append($opener).addClass(closed);

                    // toggle heading class arrow (actually switch arrow)
                    $panel.on('panelclose.' + ns + ' panelopen.' + ns, function(e, args) {
                        var fn = e.type === 'panelclose' ? 'add' : 'remove';
                        args.heading[fn + 'Class'](closed);
                    });


                    $panel.trigger('panel' + action + '.' + ns, { heading: $heading });
                });

                $sections.each(function () {

                    // assign click action to headings
                    $(this).find(heading).on('click', function (e, args) {

                        var $heading = $(this),
                            $panel   = $heading.parents(section).children(panel),
                            preserveOthers = !!(args && args.preserveOthers),
                            actions = {
                                close: 'hide',
                                open: 'fadeIn'
                            },
                            action,
                            forceState = (args && args.forceState ? args.forceState : false),
                            classFn;

                        if(forceState) {
                            classFn = forceState === 'open' ? 'addClass' : 'removeClass';
                            $heading[classFn](closed);
                        }

                        action = $heading.hasClass(closed) ? 'open' : 'close';

                        // whether or not to close other sections in the same sidebar
                        // @todo (optional): remove 'false' in the condition below
                        // to change the style to accordion, i.e. to allow for only one open section
                        if(false && !preserveOthers) {
                            $allPanels.not($panel).each(function() {
                                var $panel = $(this),
                                    $heading = $panel.parent().find(heading),
                                    _action = 'close';

                                $panel.trigger('panel' + _action + '.' + ns, { heading: $heading })[actions[_action]]();
                            });
                        }

                        $panel.trigger('panel' + action + '.' + ns, { heading: $heading })[actions[action]]();
                    });

                });
            });
        };

        /**
         * Toggle section display
         *
         * @param sections
         */
        var _toggleSections = function(sections, preserveOthers, state) {
            sections.each(function(){
                $(this).find(heading).trigger('click', { preserveOthers: preserveOthers, forceState: state });
            });
        };

        /**
         * Close specific sections
         *
         * @param sections
         */
        var closeSections = function(sections, preserveOthers) {
            _toggleSections(sections, !!preserveOthers, 'close');
        };

        /**
         * Open specific sections
         *
         * @param sections
         */
        var openSections = function(sections, preserveOthers) {
            _toggleSections(sections, !!preserveOthers, 'open');
        };

        // display the sidebar and its sections temporarily to calculate the height
        var _tmpDisplay = function($elements, reset) {
            $elements.each(function() {
                var $element = $(this);
                if(reset) {
                    $element.css('display', $element.prop('old-display'));
                    $element.css('opacity', $element.prop('old-opacity'));
                    $element.removeProp('old-display');
                    $element.removeProp('old-opacity');
                }
                else {
                    $element.prop('old-display', $element.css('display'));
                    $element.prop('old-opacity', $element.css('opacity'));
                    $element.css('display', 'block');
                    $element.css('opacity', 0);
                }
            });
        };

        /**
         * Adapt height of sidebars and content
         */
        var adaptHeight = function() {
            var height = 0;
            elements.sidebars.add(elements.itemPanel).each(function () {
                var block = $(this),
                    blocks = block.add(block.find('section hr .panel'));
                // work around the fact that the sidebars might be hidden at this point
                _tmpDisplay(blocks);
                height = Math.max(block.height(), height);
                _tmpDisplay(blocks, true);
            }).height(height);
        };

        /**
         * Initialize interface
         */
        var initGui = function () {


            // toggle blocks in sidebar
            // note that this must happen _after_ the height has been adapted
            sidebarAccordionInit();

            // close all
            closeSections(elements.sidebars.find(section));

            adaptHeight();

            /* At the time of writing this the following sections are available:
             *
             * #sidebar-left-section-text
             * #sidebar-left-section-block-interactions
             * #sidebar-left-section-inline-interactions
             * #sidebar-left-section-graphic-interactions
             * #sidebar-left-section-media
             * #sidebar-right-css-manager
             * #sidebar-right-style-editor
             * #sidebar-right-item-properties
             * #sidebar-right-body-element-properties
             * #sidebar-right-text-block-properties
             * #sidebar-right-interaction-properties
             * #sidebar-right-choice-properties
             * #sidebar-right-response-properties
             */

            openSections(
                $('#sidebar-left-section-content-blocks, #sidebar-left-section-content-elements, #sidebar-left-section-block-interactions'),
                false
            );

            elements.itemPanel.addClass('has-item');

            // display toolbar and sidebar
            //elements.sidebars.add(elements.toolbarInner).fadeTo(2000, 1);

        };

        return {
            initGui: initGui,
            openSections: openSections,
            closeSections: closeSections,
            adaptHeight: adaptHeight
        };

    }());
    return editor;
});



define('taoQtiItem/controller/creator/main',[
    'lodash',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiCreator/editor/preview',
    'taoQtiItem/qtiCreator/editor/preparePrint',
    'taoQtiItem/qtiCreator/helper/itemLoader',
    'taoQtiItem/qtiCreator/helper/creatorRenderer',
    'taoQtiItem/qtiCreator/helper/commonRenderer', //for the preview
    // css editor related
    'taoQtiItem/qtiCreator/editor/styleEditor/fontSelector',
    'taoQtiItem/qtiCreator/editor/styleEditor/colorSelector',
    'taoQtiItem/qtiCreator/editor/styleEditor/fontSizeChanger',
    'taoQtiItem/qtiCreator/editor/styleEditor/itemResizer',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleEditor',
    'taoQtiItem/qtiCreator/editor/styleEditor/styleSheetToggler',
    'taoQtiItem/qtiCreator/editor/editor'
], function(
    _,
    Element,
    preview,
    preparePrint,
    loader,
    creatorRenderer,
    commonRenderer,
    fontSelector,
    colorSelector,
    fontSizeChanger,
    itemResizer,
    styleEditor,
    styleSheetToggler,
    editor
    ){


    // workaround to get ajax loader out of the way
    // item editor has its own loader with the correct background color
    var $loader = $('#ajax-loading');
    var loaderLeft = $loader.css('left');

    var _initUiComponents = function(item, config){


        styleEditor.init(item, config);

        styleSheetToggler.init(config);

        // CSS widgets
        fontSelector();
        colorSelector();
        fontSizeChanger();
        itemResizer();
        preview.init($('.preview-trigger'), item);

        preparePrint();

        editor.initGui();

        $loader.css('left', loaderLeft);

    };

    var _showPanel = function($panel, $fold){
        
        $panel.show();
        editor.openSections($panel.children('section'));
        
        if($fold && $fold.length){
            editor.closeSections($fold.children('section'));
        }
    };

    var _initFormVisibilityListener = function(){

        $loader.css('left', '-10000px');

        // needs to be done twice, before and after the item is loaded
        // to avoid incorrect display. 2nd call is done internally
        editor.adaptHeight();


        var $itemContainer = $('#item-editor-panel');

        var _staticElements = {
            'img' : 'Image',
            'object' : 'Media',
            'rubricBlock' : 'Rubric Block',
            'modalFeedback' : 'Modal Feedback',
            'math' : 'Math'
        };

        // all sections on the right sidebar are invisible by default
        var $formInteractionPanel = $('#item-editor-interaction-property-bar'),
            $formChoicePanel = $('#item-editor-choice-property-bar'),
            $formResponsePanel = $('#item-editor-response-property-bar'),
            $formItemPanel = $('#item-editor-item-property-bar').show(),
            $formBodyElementPanel = $('#item-editor-body-element-property-bar'),
            $formTextBlockPanel = $('#item-editor-text-property-bar'),
            $formStylePanel = $('#item-style-editor-bar'),
            $appearanceToggler = $('#appearance-trigger');

        var _toggleAppearanceEditor = function(active){

            if(active){

                $appearanceToggler.addClass('active');
                $formStylePanel.show();
                $formItemPanel.hide();

                //current widget sleep:
                $itemContainer.trigger('styleedit');

                /* At the time of writing this the following sections are available:
                 *
                 * #sidebar-left-section-text
                 * #sidebar-left-section-block-interactions
                 * #sidebar-left-section-inline-interactions
                 * #sidebar-left-section-graphic-interactions
                 * #sidebar-left-section-media
                 * #sidebar-right-css-manager
                 * #sidebar-right-style-editor
                 * #sidebar-right-item-properties
                 * #sidebar-right-body-element-properties
                 * #sidebar-right-text-block-properties
                 * #sidebar-right-interaction-properties
                 * #sidebar-right-choice-properties
                 * #sidebar-right-response-properties
                 */
                _showPanel($formStylePanel);
            }else{
                $appearanceToggler.removeClass('active');
                $formStylePanel.hide();
                _showPanel($formItemPanel);
            }
        };

        $appearanceToggler.on('click', function(){

            if($appearanceToggler.hasClass('active')){
                _toggleAppearanceEditor(false);
            }
            else{
                _toggleAppearanceEditor(true);
            }
        });

        $(document).on('afterStateInit.qti-widget', function(e, element, state){

            switch(state.name){
                case 'active':

                    _toggleAppearanceEditor(false);
                    if(!Element.isA(element, 'assessmentItem')){
                        $formItemPanel.hide();
                    }

                    var label = _staticElements[element.qtiClass];
                    if(label){
                        $formBodyElementPanel.find('h2').html(label + ' Properties');
                        _showPanel($formBodyElementPanel);
                    }else if(element.qtiClass === '_container'){
                        _showPanel($formTextBlockPanel);
                    }

                    break;
                case 'question':
                    _showPanel($formInteractionPanel);
                    break;
                case 'choice':
                    _showPanel($formChoicePanel, $formInteractionPanel);
                    break;
                case 'answer':
                    _showPanel($formResponsePanel);
                    break;
                case 'sleep':

                    if(_staticElements[element.qtiClass]){
                        $formBodyElementPanel.hide();
                    }else if(element.qtiClass === '_container'){
                        $formTextBlockPanel.hide();
                    }

                    if(!Element.isA(element, 'choice')){
                        if(!$itemContainer.find('.widget-box.edit-active').length){
                            _showPanel($formItemPanel);
                        }
                    }
                    break;
            }
        });

        $(document).on('beforeStateExit.qti-widget', function(e, element, state){
            switch(state.name){
                case 'question':
                    $formInteractionPanel.hide();
                    break;
                case 'choice':
                    $formChoicePanel.hide();
                    break;
                case 'answer':
                    $formResponsePanel.hide();
                    break;
            }
        });
    };

    return {
        /**
         * 
         * @param {object} config (baseUrl, uri, lang)
         */
        start : function(config){

            _initFormVisibilityListener();

            //load item from REST service
            loader.loadItem({uri : config.uri}, function(item){

                var $itemContainer = $('#item-editor-panel');

                //configure commonRenderer for the preview
                commonRenderer.setOption('baseUrl', config.baseUrl);
                commonRenderer.setContext($itemContainer);

                //load creator renderer
                creatorRenderer.setOptions(config);
                creatorRenderer.get().load(function(){

                    item.setRenderer(this);

                    //render item (body only) into the "drop-area"
                    $itemContainer.append(item.render());

                    //"post-render it" to initialize the widget
                    item.postRender(_.clone(config));

                    _initUiComponents(item, config);

                }, item.getUsedClasses());

            });

        }
    };
});
